// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var Obj               = require("bs-platform/lib/js/obj.js");
var List              = require("bs-platform/lib/js/list.js");
var $$Array           = require("bs-platform/lib/js/array.js");
var Block             = require("bs-platform/lib/js/block.js");
var Curry             = require("bs-platform/lib/js/curry.js");
var Printf            = require("bs-platform/lib/js/printf.js");
var Random            = require("bs-platform/lib/js/random.js");
var Fixture           = require("../fixture.js");
var Caml_array        = require("bs-platform/lib/js/caml_array.js");
var Pervasives        = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions   = require("bs-platform/lib/js/caml_exceptions.js");
var Micro_bench_run   = require("../micro_bench_run.js");
var Micro_bench_types = require("../micro_bench_types.js");

var Null = Caml_exceptions.create("Nullable_array.Nullable_array_marker.Null");

var empty_array = Caml_array.caml_make_vect(1, Null);

function make(n) {
  return Caml_array.caml_make_vect(n + 1 | 0, Null);
}

function length(a) {
  return a.length - 1 | 0;
}

function set(a, n, v) {
  return Caml_array.caml_array_set(a, n + 1 | 0, v);
}

function clear(a, n) {
  return Caml_array.caml_array_set(a, n + 1 | 0, a[0]);
}

function unsafe_set(a, n, v) {
  a[n + 1 | 0] = v;
  return /* () */0;
}

function get(a, n) {
  var elt = Caml_array.caml_array_get(a, n + 1 | 0);
  var $$null = a[0];
  if (elt === $$null) {
    return /* None */0;
  } else {
    return /* Some */[elt];
  }
}

function unsafe_get(a, n) {
  var elt = a[n + 1 | 0];
  var $$null = a[0];
  if (elt === $$null) {
    return /* None */0;
  } else {
    return /* Some */[elt];
  }
}

function unsafe_get_some(a, n) {
  return a[n + 1 | 0];
}

function get_k(a, n, k_none, k_some) {
  var elt = Caml_array.caml_array_get(a, n + 1 | 0);
  var $$null = a[0];
  if (elt === $$null) {
    return Curry._1(k_none, /* () */0);
  } else {
    return Curry._1(k_some, elt);
  }
}

function unsafe_get_k(a, n, k_none, k_some) {
  var elt = a[n + 1 | 0];
  var $$null = a[0];
  if (elt === $$null) {
    return Curry._1(k_none, /* () */0);
  } else {
    return Curry._1(k_some, elt);
  }
}

function iteri_sparse(f, a) {
  var $$null = a[0];
  for(var i = 1 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    var elt = a[i];
    if (elt !== $$null) {
      Curry._2(f, i - 1 | 0, elt);
    }
    
  }
  return /* () */0;
}

function realloc(src, n) {
  var $$null = src[0];
  var result = Caml_array.caml_make_vect(n, $$null);
  var copy_lenght = Pervasives.min(src.length, result.length) - 1 | 0;
  $$Array.blit(src, 1, result, 1, copy_lenght);
  return result;
}

var Nullable_array_marker = /* module */[
  /* Null */Null,
  /* null */Null,
  /* empty_array */empty_array,
  /* make */make,
  /* length */length,
  /* set */set,
  /* clear */clear,
  /* unsafe_set */unsafe_set,
  /* get */get,
  /* unsafe_get */unsafe_get,
  /* unsafe_get_some */unsafe_get_some,
  /* get_k */get_k,
  /* unsafe_get_k */unsafe_get_k,
  /* iteri_sparse */iteri_sparse,
  /* realloc */realloc
];

function length$1(a) {
  return a.length;
}

function make$1(n) {
  return Caml_array.caml_make_vect(n, /* None */0);
}

function set$1(a, n, v) {
  return Caml_array.caml_array_set(a, n, /* Some */[v]);
}

var get$1 = Caml_array.caml_array_get;

function get_k$1(a, n, none, some) {
  var match = Caml_array.caml_array_get(a, n);
  if (match) {
    return Curry._1(some, match[0]);
  } else {
    return Curry._1(none, /* () */0);
  }
}

function iteri_sparse$1(f, a) {
  return $$Array.iteri((function (i, v) {
                if (v) {
                  return Curry._2(f, i, v[0]);
                } else {
                  return /* () */0;
                }
              }), a);
}

var Option_array = /* module */[
  /* length */length$1,
  /* make */make$1,
  /* set */set$1,
  /* get */get$1,
  /* get_k */get_k$1,
  /* iteri_sparse */iteri_sparse$1
];

var Null$1 = Caml_exceptions.create("Nullable_array.Nullable_array_closure.Null");

var $$null = (function () {
      return Null$1;
    })[0];

function make$2(n) {
  var a = Caml_array.caml_make_vect(n, $$null);
  a.tag = Obj.closure_tag;
  return a;
}

function length$2(a) {
  return a.length;
}

var set$2 = Caml_array.caml_array_set;

function get$2(a, n) {
  var elt = Caml_array.caml_array_get(a, n);
  if (elt === $$null) {
    return /* None */0;
  } else {
    return /* Some */[elt];
  }
}

function get_k$2(a, n, k_none, k_some) {
  var elt = Caml_array.caml_array_get(a, n);
  if (elt === $$null) {
    return Curry._1(k_none, /* () */0);
  } else {
    return Curry._1(k_some, elt);
  }
}

function iteri_sparse$2(f, a) {
  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    var elt = a[i];
    if (elt !== $$null) {
      Curry._2(f, i, elt);
    }
    
  }
  return /* () */0;
}

var Nullable_array_closure = /* module */[
  /* Null */Null$1,
  /* null */$$null,
  /* make */make$2,
  /* length */length$2,
  /* set */set$2,
  /* get */get$2,
  /* get_k */get_k$2,
  /* iteri_sparse */iteri_sparse$2
];

function random_prepare(n) {
  return Random.State[/* make */0](/* int array */[n]);
}

function random_permutation(state, a) {
  var len = a.length;
  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    var n = Random.State[/* int */4](state, len - i | 0) + i | 0;
    var v1 = Caml_array.caml_array_get(a, i);
    var v2 = Caml_array.caml_array_get(a, n);
    Caml_array.caml_array_set(a, i, v2);
    Caml_array.caml_array_set(a, n, v1);
  }
  return a;
}

function random_indices(state, n) {
  var a = $$Array.init(n, (function (i) {
          return i;
        }));
  return random_permutation(state, a);
}

function random_selection(state, size, n) {
  var indices = random_indices(state, size);
  return $$Array.init(n, (function (i) {
                return Caml_array.caml_array_get(indices, i);
              }));
}

function prepare_random_option_array(density, size) {
  var state = Random.State[/* make */0](/* int array */[size]);
  var n = size * density | 0;
  var selection = random_selection(state, size, n);
  var a = Caml_array.caml_make_vect(size, /* None */0);
  $$Array.iter((function (i) {
          return set$1(a, i, i);
        }), selection);
  return a;
}

function prepare_random_path(density, size) {
  var state = Random.State[/* make */0](/* int array */[size]);
  var size$1 = Pervasives.max(3, size);
  var n = (size$1 * density | 0) - 1 | 0;
  var n$1 = Pervasives.min(size$1 - 2 | 0, Pervasives.max(1, n));
  var selection = random_selection(state, size$1 - 2 | 0, n$1);
  var a = Caml_array.caml_make_vect(size$1, /* None */0);
  set$1(a, 0, Caml_array.caml_array_get(selection, 0) + 1 | 0);
  for(var i = 0 ,i_finish = n$1 - 2 | 0; i <= i_finish; ++i){
    set$1(a, Caml_array.caml_array_get(selection, i) + 1 | 0, Caml_array.caml_array_get(selection, i + 1 | 0) + 1 | 0);
  }
  return a;
}

function Bench(M) {
  return (function (Get) {
      var name = Get[/* name */0];
      var copy_option_array = function (oa) {
        var a = Curry._1(M[/* make */1], oa.length);
        iteri_sparse$1((function (i, v) {
                return Curry._3(M[/* set */2], a, i, v);
              }), oa);
        return a;
      };
      var sum = function (a) {
        var r = [0];
        Curry._2(M[/* iteri_sparse */5], (function (_, i) {
                r[0] = i + r[0] | 0;
                return /* () */0;
              }), a);
        return r[0];
      };
      var sum_prepared_array = function (a) {
        return sum(Curry._1(Get[/* get */1], a));
      };
      var walk = function (a) {
        var _i = 0;
        var _count = 0;
        while(true) {
          var count = _count;
          var i = _i;
          var match = Curry._2(M[/* get */3], a, i);
          if (match) {
            _count = count + 1 | 0;
            _i = match[0];
            continue ;
            
          } else {
            return count;
          }
        };
      };
      var walk_prepared_array = function (a) {
        return walk(Curry._1(Get[/* get */1], a));
      };
      var walk_k = function (a) {
        var loop = function (i, count) {
          return Curry._4(M[/* get_k */4], a, i, (function () {
                        return count;
                      }), (function (next) {
                        return loop(next, count + 1 | 0);
                      }));
        };
        return loop(0, 0);
      };
      var walk_k_prepared_array = function (a) {
        return walk_k(Curry._1(Get[/* get */1], a));
      };
      var sum_bench = /* tuple */[
        name,
        sum_prepared_array
      ];
      var walk_bench = /* tuple */[
        name,
        walk_prepared_array
      ];
      var walk_k_bench_000 = name + "_k";
      var walk_k_bench = /* tuple */[
        walk_k_bench_000,
        walk_k_prepared_array
      ];
      return /* module */[
              /* name */name,
              /* copy_option_array */copy_option_array,
              /* sum */sum,
              /* sum_prepared_array */sum_prepared_array,
              /* walk */walk,
              /* walk_prepared_array */walk_prepared_array,
              /* walk_k */walk_k,
              /* walk_k_prepared_array */walk_k_prepared_array,
              /* sum_bench */sum_bench,
              /* walk_bench */walk_bench,
              /* walk_k_bench */walk_k_bench
            ];
    });
}

var name = "option_array";

function get$3(param) {
  return param[/* option_array */0];
}

function copy_option_array(oa) {
  var a = Caml_array.caml_make_vect(oa.length, /* None */0);
  iteri_sparse$1((function (i, v) {
          return set$1(a, i, v);
        }), oa);
  return a;
}

function sum(a) {
  var r = [0];
  iteri_sparse$1((function (_, i) {
          r[0] = i + r[0] | 0;
          return /* () */0;
        }), a);
  return r[0];
}

function sum_prepared_array(a) {
  return sum(get$3(a));
}

function walk(a) {
  var _i = 0;
  var _count = 0;
  while(true) {
    var count = _count;
    var i = _i;
    var match = Caml_array.caml_array_get(a, i);
    if (match) {
      _count = count + 1 | 0;
      _i = match[0];
      continue ;
      
    } else {
      return count;
    }
  };
}

function walk_prepared_array(a) {
  return walk(get$3(a));
}

function walk_k(a) {
  var loop = function (i, count) {
    return get_k$1(a, i, (function () {
                  return count;
                }), (function (next) {
                  return loop(next, count + 1 | 0);
                }));
  };
  return loop(0, 0);
}

function walk_k_prepared_array(a) {
  return walk_k(get$3(a));
}

var sum_bench = /* tuple */[
  name,
  sum_prepared_array
];

var walk_bench = /* tuple */[
  name,
  walk_prepared_array
];

var walk_k_bench = /* tuple */[
  "option_array_k",
  walk_k_prepared_array
];

var OA = /* module */[
  /* name */name,
  /* copy_option_array */copy_option_array,
  /* sum */sum,
  /* sum_prepared_array */sum_prepared_array,
  /* walk */walk,
  /* walk_prepared_array */walk_prepared_array,
  /* walk_k */walk_k,
  /* walk_k_prepared_array */walk_k_prepared_array,
  /* sum_bench */sum_bench,
  /* walk_bench */walk_bench,
  /* walk_k_bench */walk_k_bench
];

function get$4(param) {
  return param[/* nullable_array_closure */1];
}

var NAC = (function (Get) {
      var name = Get[/* name */0];
      var copy_option_array = function (oa) {
        var a = make$2(oa.length);
        iteri_sparse$1((function (i, v) {
                return Caml_array.caml_array_set(a, i, v);
              }), oa);
        return a;
      };
      var sum = function (a) {
        var r = [0];
        iteri_sparse$2((function (_, i) {
                r[0] = i + r[0] | 0;
                return /* () */0;
              }), a);
        return r[0];
      };
      var sum_prepared_array = function (a) {
        return sum(Curry._1(Get[/* get */1], a));
      };
      var walk = function (a) {
        var _i = 0;
        var _count = 0;
        while(true) {
          var count = _count;
          var i = _i;
          var match = get$2(a, i);
          if (match) {
            _count = count + 1 | 0;
            _i = match[0];
            continue ;
            
          } else {
            return count;
          }
        };
      };
      var walk_prepared_array = function (a) {
        return walk(Curry._1(Get[/* get */1], a));
      };
      var walk_k = function (a) {
        var loop = function (i, count) {
          return get_k$2(a, i, (function () {
                        return count;
                      }), (function (next) {
                        return loop(next, count + 1 | 0);
                      }));
        };
        return loop(0, 0);
      };
      var walk_k_prepared_array = function (a) {
        return walk_k(Curry._1(Get[/* get */1], a));
      };
      var sum_bench = /* tuple */[
        name,
        sum_prepared_array
      ];
      var walk_bench = /* tuple */[
        name,
        walk_prepared_array
      ];
      var walk_k_bench_000 = name + "_k";
      var walk_k_bench = /* tuple */[
        walk_k_bench_000,
        walk_k_prepared_array
      ];
      return /* module */[
              /* name */name,
              /* copy_option_array */copy_option_array,
              /* sum */sum,
              /* sum_prepared_array */sum_prepared_array,
              /* walk */walk,
              /* walk_prepared_array */walk_prepared_array,
              /* walk_k */walk_k,
              /* walk_k_prepared_array */walk_k_prepared_array,
              /* sum_bench */sum_bench,
              /* walk_bench */walk_bench,
              /* walk_k_bench */walk_k_bench
            ];
    })(/* module */[
      /* name */"nullable_array_closure",
      /* get */get$4
    ]);

function get$5(param) {
  return param[/* nullable_array_marker */2];
}

var NAM = (function (Get) {
      var name = Get[/* name */0];
      var copy_option_array = function (oa) {
        var a = make(oa.length);
        iteri_sparse$1((function (i, v) {
                return set(a, i, v);
              }), oa);
        return a;
      };
      var sum = function (a) {
        var r = [0];
        iteri_sparse((function (_, i) {
                r[0] = i + r[0] | 0;
                return /* () */0;
              }), a);
        return r[0];
      };
      var sum_prepared_array = function (a) {
        return sum(Curry._1(Get[/* get */1], a));
      };
      var walk = function (a) {
        var _i = 0;
        var _count = 0;
        while(true) {
          var count = _count;
          var i = _i;
          var match = get(a, i);
          if (match) {
            _count = count + 1 | 0;
            _i = match[0];
            continue ;
            
          } else {
            return count;
          }
        };
      };
      var walk_prepared_array = function (a) {
        return walk(Curry._1(Get[/* get */1], a));
      };
      var walk_k = function (a) {
        var loop = function (i, count) {
          return get_k(a, i, (function () {
                        return count;
                      }), (function (next) {
                        return loop(next, count + 1 | 0);
                      }));
        };
        return loop(0, 0);
      };
      var walk_k_prepared_array = function (a) {
        return walk_k(Curry._1(Get[/* get */1], a));
      };
      var sum_bench = /* tuple */[
        name,
        sum_prepared_array
      ];
      var walk_bench = /* tuple */[
        name,
        walk_prepared_array
      ];
      var walk_k_bench_000 = name + "_k";
      var walk_k_bench = /* tuple */[
        walk_k_bench_000,
        walk_k_prepared_array
      ];
      return /* module */[
              /* name */name,
              /* copy_option_array */copy_option_array,
              /* sum */sum,
              /* sum_prepared_array */sum_prepared_array,
              /* walk */walk,
              /* walk_prepared_array */walk_prepared_array,
              /* walk_k */walk_k,
              /* walk_k_prepared_array */walk_k_prepared_array,
              /* sum_bench */sum_bench,
              /* walk_bench */walk_bench,
              /* walk_k_bench */walk_k_bench
            ];
    })(/* module */[
      /* name */"nullable_array_marker",
      /* get */get$5
    ]);

function copy_prepared_option_array(base_array) {
  return /* record */[
          /* option_array */copy_option_array(base_array),
          /* nullable_array_closure */Curry._1(NAC[/* copy_option_array */1], base_array),
          /* nullable_array_marker */Curry._1(NAM[/* copy_option_array */1], base_array)
        ];
}

function check_sum_option_array(density, size, res) {
  var oa = prepare_random_option_array(density, size);
  var sum$1 = sum(oa);
  if (sum$1 === res) {
    return /* Ok */0;
  } else {
    return /* Error */[Curry._2(Printf.sprintf(/* Format */[
                      /* String_literal */Block.__(11, [
                          "Incorrect sum: ",
                          /* Int */Block.__(4, [
                              /* Int_i */3,
                              /* No_padding */0,
                              /* No_precision */0,
                              /* String_literal */Block.__(11, [
                                  ", expected ",
                                  /* Int */Block.__(4, [
                                      /* Int_i */3,
                                      /* No_padding */0,
                                      /* No_precision */0,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ]),
                      "Incorrect sum: %i, expected %i"
                    ]), res, sum$1)];
  }
}

function prepare_random_array(density, size) {
  return copy_prepared_option_array(prepare_random_option_array(density, size));
}

function sum$1(density) {
  return /* tuple */[
          Curry._1(Printf.sprintf(/* Format */[
                    /* String_literal */Block.__(11, [
                        "sum ",
                        /* Float */Block.__(8, [
                            /* Float_f */0,
                            /* Lit_padding */Block.__(0, [
                                /* Right */1,
                                0
                              ]),
                            /* Lit_precision */[2],
                            /* End_of_format */0
                          ])
                      ]),
                    "sum %0.2f"
                  ]), density),
          /* Int_group */Block.__(3, [/* tuple */[
                /* :: */[
                  sum_bench,
                  /* :: */[
                    NAC[/* sum_bench */8],
                    /* :: */[
                      NAM[/* sum_bench */8],
                      /* [] */0
                    ]
                  ]
                ],
                (function (param) {
                    return copy_prepared_option_array(prepare_random_option_array(density, param));
                  }),
                (function (param, param$1) {
                    return check_sum_option_array(density, param, param$1);
                  }),
                /* :: */[
                  /* tuple */[
                    /* Range */Block.__(0, [
                        100,
                        100000
                      ]),
                    /* Short */0
                  ],
                  /* [] */0
                ]
              ]])
        ];
}

function check_walk(density, size, res) {
  var oa = prepare_random_path(density, size);
  var length = walk(oa);
  if (length === res) {
    return /* Ok */0;
  } else {
    return /* Error */[Curry._2(Printf.sprintf(/* Format */[
                      /* String_literal */Block.__(11, [
                          "Incorrect walk length: ",
                          /* Int */Block.__(4, [
                              /* Int_i */3,
                              /* No_padding */0,
                              /* No_precision */0,
                              /* String_literal */Block.__(11, [
                                  ", expected ",
                                  /* Int */Block.__(4, [
                                      /* Int_i */3,
                                      /* No_padding */0,
                                      /* No_precision */0,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ]),
                      "Incorrect walk length: %i, expected %i"
                    ]), res, length)];
  }
}

function prepare_walk(density, size) {
  return copy_prepared_option_array(prepare_random_path(density, size));
}

function walk$1(density) {
  return /* tuple */[
          Curry._1(Printf.sprintf(/* Format */[
                    /* String_literal */Block.__(11, [
                        "walk ",
                        /* Float */Block.__(8, [
                            /* Float_f */0,
                            /* Lit_padding */Block.__(0, [
                                /* Right */1,
                                0
                              ]),
                            /* Lit_precision */[2],
                            /* End_of_format */0
                          ])
                      ]),
                    "walk %0.2f"
                  ]), density),
          /* Int_group */Block.__(3, [/* tuple */[
                /* :: */[
                  walk_bench,
                  /* :: */[
                    walk_k_bench,
                    /* :: */[
                      NAC[/* walk_bench */9],
                      /* :: */[
                        NAC[/* walk_k_bench */10],
                        /* :: */[
                          NAM[/* walk_bench */9],
                          /* :: */[
                            NAM[/* walk_k_bench */10],
                            /* [] */0
                          ]
                        ]
                      ]
                    ]
                  ]
                ],
                (function (param) {
                    return copy_prepared_option_array(prepare_random_path(density, param));
                  }),
                (function (param, param$1) {
                    return check_walk(density, param, param$1);
                  }),
                /* :: */[
                  /* tuple */[
                    /* Range */Block.__(0, [
                        100,
                        3000
                      ]),
                    /* Short */0
                  ],
                  /* [] */0
                ]
              ]])
        ];
}

var densities = /* :: */[
  1,
  /* :: */[
    0.3,
    /* :: */[
      0.01,
      /* [] */0
    ]
  ]
];

var functions = Pervasives.$at(List.map(sum$1, densities), List.map(walk$1, densities));

Micro_bench_types.add(functions);

var config = Micro_bench_run.Config[/* parse */1](/* () */0);

if (typeof config === "number") {
  Micro_bench_run.run(/* Some */[/* Some */[config]], Micro_bench_types.functions(/* () */0));
} else if (config[0] !== 4103979) {
  Micro_bench_run.run(/* Some */[/* Some */[config]], Micro_bench_types.functions(/* () */0));
} else {
  var conf = config[1];
  Fixture.run_n_times(1, (function () {
          var newrecord = conf.slice();
          return Micro_bench_run.run(/* Some */[/* Some */[/* `Run */[
                          4103979,
                          (newrecord[/* number_of_different_values */5] = 10, newrecord)
                        ]]], Micro_bench_types.functions(/* () */0));
        }));
}

exports.Nullable_array_marker       = Nullable_array_marker;
exports.Option_array                = Option_array;
exports.Nullable_array_closure      = Nullable_array_closure;
exports.random_prepare              = random_prepare;
exports.random_permutation          = random_permutation;
exports.random_indices              = random_indices;
exports.random_selection            = random_selection;
exports.prepare_random_option_array = prepare_random_option_array;
exports.prepare_random_path         = prepare_random_path;
exports.Bench                       = Bench;
exports.OA                          = OA;
exports.NAC                         = NAC;
exports.NAM                         = NAM;
exports.copy_prepared_option_array  = copy_prepared_option_array;
exports.check_sum_option_array      = check_sum_option_array;
exports.prepare_random_array        = prepare_random_array;
exports.sum                         = sum$1;
exports.check_walk                  = check_walk;
exports.prepare_walk                = prepare_walk;
exports.walk                        = walk$1;
exports.functions                   = functions;
/* NAC Not a pure module */
