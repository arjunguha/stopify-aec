// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var Block                   = require("bs-platform/lib/js/block.js");
var Fixture                 = require("../fixture.js");
var Caml_obj                = require("bs-platform/lib/js/caml_obj.js");
var Caml_array              = require("bs-platform/lib/js/caml_array.js");
var Caml_int32              = require("bs-platform/lib/js/caml_int32.js");
var Micro_bench_run         = require("../micro_bench_run.js");
var Micro_bench_types       = require("../micro_bench_types.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function $$eval(_bdd, vars) {
  while(true) {
    var bdd = _bdd;
    if (typeof bdd === "number") {
      if (bdd !== 0) {
        return /* false */0;
      } else {
        return /* true */1;
      }
    } else if (Caml_array.caml_array_get(vars, bdd[1])) {
      _bdd = bdd[3];
      continue ;
      
    } else {
      _bdd = bdd[0];
      continue ;
      
    }
  };
}

function getId(bdd) {
  if (typeof bdd === "number") {
    if (bdd !== 0) {
      return 0;
    } else {
      return 1;
    }
  } else {
    return bdd[2];
  }
}

function Build() {
  var nodeC = [1];
  var sz_1 = [8191];
  var htab = [Caml_array.caml_make_vect(sz_1[0] + 1 | 0, /* [] */0)];
  var n_items = [0];
  var hashVal = function (x, y, v) {
    return ((x << 1) + y | 0) + (v << 2) | 0;
  };
  var resize = function (newSize) {
    var arr = htab[0];
    var newSz_1 = newSize - 1 | 0;
    var newArr = Caml_array.caml_make_vect(newSize, /* [] */0);
    var copyBucket = function (_bucket) {
      while(true) {
        var bucket = _bucket;
        if (bucket) {
          var n = bucket[0];
          if (typeof n === "number") {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "bdd.ml",
                    55,
                    15
                  ]
                ];
          } else {
            var ind = hashVal(getId(n[0]), getId(n[3]), n[1]) & newSz_1;
            Caml_array.caml_array_set(newArr, ind, /* :: */[
                  n,
                  Caml_array.caml_array_get(newArr, ind)
                ]);
            _bucket = bucket[1];
            continue ;
            
          }
        } else {
          return /* () */0;
        }
      };
    };
    for(var n = 0 ,n_finish = sz_1[0]; n <= n_finish; ++n){
      copyBucket(Caml_array.caml_array_get(arr, n));
    }
    htab[0] = newArr;
    sz_1[0] = newSz_1;
    return /* () */0;
  };
  var insert = function (idl, idh, v, ind, bucket, newNode) {
    if (n_items[0] <= sz_1[0]) {
      Caml_array.caml_array_set(htab[0], ind, /* :: */[
            newNode,
            bucket
          ]);
      n_items[0] = n_items[0] + 1 | 0;
      return /* () */0;
    } else {
      resize((sz_1[0] + sz_1[0] | 0) + 2 | 0);
      var ind$1 = hashVal(idl, idh, v) & sz_1[0];
      return Caml_array.caml_array_set(htab[0], ind$1, /* :: */[
                  newNode,
                  Caml_array.caml_array_get(htab[0], ind$1)
                ]);
    }
  };
  var resetUnique = function () {
    sz_1[0] = 8191;
    htab[0] = Caml_array.caml_make_vect(sz_1[0] + 1 | 0, /* [] */0);
    n_items[0] = 0;
    nodeC[0] = 1;
    return /* () */0;
  };
  var mkNode = function (low, v, high) {
    var idl = getId(low);
    var idh = getId(high);
    if (idl === idh) {
      return low;
    } else {
      var ind = hashVal(idl, idh, v) & sz_1[0];
      var bucket = Caml_array.caml_array_get(htab[0], ind);
      var _b = bucket;
      while(true) {
        var b = _b;
        if (b) {
          var n = b[0];
          if (typeof n === "number") {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "bdd.ml",
                    100,
                    17
                  ]
                ];
          } else if (v === n[1] && idl === getId(n[0]) && idh === getId(n[3])) {
            return n;
          } else {
            _b = b[1];
            continue ;
            
          }
        } else {
          var n_002 = (nodeC[0] = nodeC[0] + 1 | 0, nodeC[0]);
          var n$1 = /* Node */[
            low,
            v,
            n_002,
            high
          ];
          insert(getId(low), getId(high), v, ind, bucket, n$1);
          return n$1;
        }
      };
    }
  };
  var cmpVar = function (x, y) {
    if (x < y) {
      return /* LESS */0;
    } else if (x > y) {
      return /* GREATER */2;
    } else {
      return /* EQUAL */1;
    }
  };
  var mkVar = function (x) {
    return mkNode(/* Zero */1, x, /* One */0);
  };
  var andslot1 = Caml_array.caml_make_vect(1999, 0);
  var andslot2 = Caml_array.caml_make_vect(1999, 0);
  var andslot3 = Caml_array.caml_make_vect(1999, /* Zero */1);
  var xorslot1 = Caml_array.caml_make_vect(1999, 0);
  var xorslot2 = Caml_array.caml_make_vect(1999, 0);
  var xorslot3 = Caml_array.caml_make_vect(1999, /* Zero */1);
  var notslot1 = Caml_array.caml_make_vect(1999, 0);
  var notslot2 = Caml_array.caml_make_vect(1999, /* One */0);
  var hash = function (x, y) {
    return ((x << 1) + y | 0) % 1999;
  };
  var not = function (n) {
    if (typeof n === "number") {
      if (n !== 0) {
        return /* One */0;
      } else {
        return /* Zero */1;
      }
    } else {
      var id = n[2];
      var h = id % 1999;
      if (id === Caml_array.caml_array_get(notslot1, h)) {
        return Caml_array.caml_array_get(notslot2, h);
      } else {
        var f = mkNode(not(n[0]), n[1], not(n[3]));
        Caml_array.caml_array_set(notslot1, h, id);
        Caml_array.caml_array_set(notslot2, h, f);
        return f;
      }
    }
  };
  var and2 = function (n1, n2) {
    if (typeof n1 === "number") {
      if (n1 !== 0) {
        return /* Zero */1;
      } else {
        return n2;
      }
    } else {
      var r1 = n1[3];
      var i1 = n1[2];
      var v1 = n1[1];
      var l1 = n1[0];
      if (typeof n2 === "number") {
        if (n2 !== 0) {
          return /* Zero */1;
        } else {
          return n1;
        }
      } else {
        var r2 = n2[3];
        var i2 = n2[2];
        var v2 = n2[1];
        var l2 = n2[0];
        var h = hash(i1, i2);
        if (i1 === Caml_array.caml_array_get(andslot1, h) && i2 === Caml_array.caml_array_get(andslot2, h)) {
          return Caml_array.caml_array_get(andslot3, h);
        } else {
          var match = cmpVar(v1, v2);
          var f;
          switch (match) {
            case 0 : 
                f = mkNode(and2(l1, n2), v1, and2(r1, n2));
                break;
            case 1 : 
                f = mkNode(and2(l1, l2), v1, and2(r1, r2));
                break;
            case 2 : 
                f = mkNode(and2(n1, l2), v2, and2(n1, r2));
                break;
            
          }
          Caml_array.caml_array_set(andslot1, h, i1);
          Caml_array.caml_array_set(andslot2, h, i2);
          Caml_array.caml_array_set(andslot3, h, f);
          return f;
        }
      }
    }
  };
  var xor = function (n1, n2) {
    if (typeof n1 === "number") {
      if (n1 !== 0) {
        return n2;
      } else {
        return not(n2);
      }
    } else {
      var r1 = n1[3];
      var i1 = n1[2];
      var v1 = n1[1];
      var l1 = n1[0];
      if (typeof n2 === "number") {
        if (n2 !== 0) {
          return n1;
        } else {
          return not(n1);
        }
      } else {
        var r2 = n2[3];
        var i2 = n2[2];
        var v2 = n2[1];
        var l2 = n2[0];
        var h = hash(i1, i2);
        if (i1 === Caml_array.caml_array_get(andslot1, h) && i2 === Caml_array.caml_array_get(andslot2, h)) {
          return Caml_array.caml_array_get(andslot3, h);
        } else {
          var match = cmpVar(v1, v2);
          var f;
          switch (match) {
            case 0 : 
                f = mkNode(xor(l1, n2), v1, xor(r1, n2));
                break;
            case 1 : 
                f = mkNode(xor(l1, l2), v1, xor(r1, r2));
                break;
            case 2 : 
                f = mkNode(xor(n1, l2), v2, xor(n1, r2));
                break;
            
          }
          Caml_array.caml_array_set(andslot1, h, i1);
          Caml_array.caml_array_set(andslot2, h, i2);
          Caml_array.caml_array_set(andslot3, h, f);
          return f;
        }
      }
    }
  };
  var hwb = function (n) {
    var h = function (i, j) {
      if (i === j) {
        return mkNode(/* Zero */1, i, /* One */0);
      } else {
        return xor(and2(not(mkNode(/* Zero */1, j, /* One */0)), h(i, j - 1 | 0)), and2(mkNode(/* Zero */1, j, /* One */0), g(i, j - 1 | 0)));
      }
    };
    var g = function (i, j) {
      if (i === j) {
        return mkNode(/* Zero */1, i, /* One */0);
      } else {
        return xor(and2(not(mkNode(/* Zero */1, i, /* One */0)), h(i + 1 | 0, j)), and2(mkNode(/* Zero */1, i, /* One */0), g(i + 1 | 0, j)));
      }
    };
    return h(0, n - 1 | 0);
  };
  return /* module */[
          /* initSize_1 */8191,
          /* nodeC */nodeC,
          /* sz_1 */sz_1,
          /* htab */htab,
          /* n_items */n_items,
          /* hashVal */hashVal,
          /* resize */resize,
          /* insert */insert,
          /* resetUnique */resetUnique,
          /* mkNode */mkNode,
          /* cmpVar */cmpVar,
          /* zero : Zero */1,
          /* one : One */0,
          /* mkVar */mkVar,
          /* cacheSize */1999,
          /* andslot1 */andslot1,
          /* andslot2 */andslot2,
          /* andslot3 */andslot3,
          /* xorslot1 */xorslot1,
          /* xorslot2 */xorslot2,
          /* xorslot3 */xorslot3,
          /* notslot1 */notslot1,
          /* notslot2 */notslot2,
          /* hash */hash,
          /* not */not,
          /* and2 */and2,
          /* xor */xor,
          /* hwb */hwb
        ];
}

function random_vars(n) {
  var seed = [0];
  var random = function () {
    seed[0] = Caml_int32.imul(seed[0], 25173) + 17431 | 0;
    return +((seed[0] & 1) > 0);
  };
  var vars = Caml_array.caml_make_vect(n, /* false */0);
  for(var i = 0 ,i_finish = n - 1 | 0; i <= i_finish; ++i){
    Caml_array.caml_array_set(vars, i, random(/* () */0));
  }
  return vars;
}

function count_true(vars) {
  var ntrue = 0;
  for(var i = 0 ,i_finish = vars.length - 1 | 0; i <= i_finish; ++i){
    if (Caml_array.caml_array_get(vars, i)) {
      ntrue = ntrue + 1 | 0;
    }
    
  }
  return ntrue;
}

function prepare_eval(i) {
  var vars = random_vars(i);
  var ntrue = count_true(vars);
  var nodeC = [1];
  var sz_1 = [8191];
  var htab = [Caml_array.caml_make_vect(sz_1[0] + 1 | 0, /* [] */0)];
  var n_items = [0];
  var hashVal = function (x, y, v) {
    return ((x << 1) + y | 0) + (v << 2) | 0;
  };
  var resize = function (newSize) {
    var arr = htab[0];
    var newSz_1 = newSize - 1 | 0;
    var newArr = Caml_array.caml_make_vect(newSize, /* [] */0);
    var copyBucket = function (_bucket) {
      while(true) {
        var bucket = _bucket;
        if (bucket) {
          var n = bucket[0];
          if (typeof n === "number") {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "bdd.ml",
                    55,
                    15
                  ]
                ];
          } else {
            var ind = hashVal(getId(n[0]), getId(n[3]), n[1]) & newSz_1;
            Caml_array.caml_array_set(newArr, ind, /* :: */[
                  n,
                  Caml_array.caml_array_get(newArr, ind)
                ]);
            _bucket = bucket[1];
            continue ;
            
          }
        } else {
          return /* () */0;
        }
      };
    };
    for(var n = 0 ,n_finish = sz_1[0]; n <= n_finish; ++n){
      copyBucket(Caml_array.caml_array_get(arr, n));
    }
    htab[0] = newArr;
    sz_1[0] = newSz_1;
    return /* () */0;
  };
  var insert = function (idl, idh, v, ind, bucket, newNode) {
    if (n_items[0] <= sz_1[0]) {
      Caml_array.caml_array_set(htab[0], ind, /* :: */[
            newNode,
            bucket
          ]);
      n_items[0] = n_items[0] + 1 | 0;
      return /* () */0;
    } else {
      resize((sz_1[0] + sz_1[0] | 0) + 2 | 0);
      var ind$1 = hashVal(idl, idh, v) & sz_1[0];
      return Caml_array.caml_array_set(htab[0], ind$1, /* :: */[
                  newNode,
                  Caml_array.caml_array_get(htab[0], ind$1)
                ]);
    }
  };
  var mkNode = function (low, v, high) {
    var idl = getId(low);
    var idh = getId(high);
    if (idl === idh) {
      return low;
    } else {
      var ind = hashVal(idl, idh, v) & sz_1[0];
      var bucket = Caml_array.caml_array_get(htab[0], ind);
      var _b = bucket;
      while(true) {
        var b = _b;
        if (b) {
          var n = b[0];
          if (typeof n === "number") {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "bdd.ml",
                    100,
                    17
                  ]
                ];
          } else if (v === n[1] && idl === getId(n[0]) && idh === getId(n[3])) {
            return n;
          } else {
            _b = b[1];
            continue ;
            
          }
        } else {
          var n_002 = (nodeC[0] = nodeC[0] + 1 | 0, nodeC[0]);
          var n$1 = /* Node */[
            low,
            v,
            n_002,
            high
          ];
          insert(getId(low), getId(high), v, ind, bucket, n$1);
          return n$1;
        }
      };
    }
  };
  var cmpVar = function (x, y) {
    if (x < y) {
      return /* LESS */0;
    } else if (x > y) {
      return /* GREATER */2;
    } else {
      return /* EQUAL */1;
    }
  };
  var andslot1 = Caml_array.caml_make_vect(1999, 0);
  var andslot2 = Caml_array.caml_make_vect(1999, 0);
  var andslot3 = Caml_array.caml_make_vect(1999, /* Zero */1);
  var notslot1 = Caml_array.caml_make_vect(1999, 0);
  var notslot2 = Caml_array.caml_make_vect(1999, /* One */0);
  var hash = function (x, y) {
    return ((x << 1) + y | 0) % 1999;
  };
  var not = function (n) {
    if (typeof n === "number") {
      if (n !== 0) {
        return /* One */0;
      } else {
        return /* Zero */1;
      }
    } else {
      var id = n[2];
      var h = id % 1999;
      if (id === Caml_array.caml_array_get(notslot1, h)) {
        return Caml_array.caml_array_get(notslot2, h);
      } else {
        var f = mkNode(not(n[0]), n[1], not(n[3]));
        Caml_array.caml_array_set(notslot1, h, id);
        Caml_array.caml_array_set(notslot2, h, f);
        return f;
      }
    }
  };
  var and2 = function (n1, n2) {
    if (typeof n1 === "number") {
      if (n1 !== 0) {
        return /* Zero */1;
      } else {
        return n2;
      }
    } else {
      var r1 = n1[3];
      var i1 = n1[2];
      var v1 = n1[1];
      var l1 = n1[0];
      if (typeof n2 === "number") {
        if (n2 !== 0) {
          return /* Zero */1;
        } else {
          return n1;
        }
      } else {
        var r2 = n2[3];
        var i2 = n2[2];
        var v2 = n2[1];
        var l2 = n2[0];
        var h = hash(i1, i2);
        if (i1 === Caml_array.caml_array_get(andslot1, h) && i2 === Caml_array.caml_array_get(andslot2, h)) {
          return Caml_array.caml_array_get(andslot3, h);
        } else {
          var match = cmpVar(v1, v2);
          var f;
          switch (match) {
            case 0 : 
                f = mkNode(and2(l1, n2), v1, and2(r1, n2));
                break;
            case 1 : 
                f = mkNode(and2(l1, l2), v1, and2(r1, r2));
                break;
            case 2 : 
                f = mkNode(and2(n1, l2), v2, and2(n1, r2));
                break;
            
          }
          Caml_array.caml_array_set(andslot1, h, i1);
          Caml_array.caml_array_set(andslot2, h, i2);
          Caml_array.caml_array_set(andslot3, h, f);
          return f;
        }
      }
    }
  };
  var xor = function (n1, n2) {
    if (typeof n1 === "number") {
      if (n1 !== 0) {
        return n2;
      } else {
        return not(n2);
      }
    } else {
      var r1 = n1[3];
      var i1 = n1[2];
      var v1 = n1[1];
      var l1 = n1[0];
      if (typeof n2 === "number") {
        if (n2 !== 0) {
          return n1;
        } else {
          return not(n1);
        }
      } else {
        var r2 = n2[3];
        var i2 = n2[2];
        var v2 = n2[1];
        var l2 = n2[0];
        var h = hash(i1, i2);
        if (i1 === Caml_array.caml_array_get(andslot1, h) && i2 === Caml_array.caml_array_get(andslot2, h)) {
          return Caml_array.caml_array_get(andslot3, h);
        } else {
          var match = cmpVar(v1, v2);
          var f;
          switch (match) {
            case 0 : 
                f = mkNode(xor(l1, n2), v1, xor(r1, n2));
                break;
            case 1 : 
                f = mkNode(xor(l1, l2), v1, xor(r1, r2));
                break;
            case 2 : 
                f = mkNode(xor(n1, l2), v2, xor(n1, r2));
                break;
            
          }
          Caml_array.caml_array_set(andslot1, h, i1);
          Caml_array.caml_array_set(andslot2, h, i2);
          Caml_array.caml_array_set(andslot3, h, f);
          return f;
        }
      }
    }
  };
  var hwb = function (n) {
    var h = function (i, j) {
      if (i === j) {
        return mkNode(/* Zero */1, i, /* One */0);
      } else {
        return xor(and2(not(mkNode(/* Zero */1, j, /* One */0)), h(i, j - 1 | 0)), and2(mkNode(/* Zero */1, j, /* One */0), g(i, j - 1 | 0)));
      }
    };
    var g = function (i, j) {
      if (i === j) {
        return mkNode(/* Zero */1, i, /* One */0);
      } else {
        return xor(and2(not(mkNode(/* Zero */1, i, /* One */0)), h(i + 1 | 0, j)), and2(mkNode(/* Zero */1, i, /* One */0), g(i + 1 | 0, j)));
      }
    };
    return h(0, n - 1 | 0);
  };
  var bdd = hwb(i);
  return /* tuple */[
          vars,
          ntrue,
          bdd
        ];
}

function run_eval(param) {
  return $$eval(param[2], param[0]);
}

function check_eval(n, result) {
  var match = prepare_eval(n);
  var ntrue = match[1];
  if (Caml_obj.caml_equal(result, ntrue > 0 ? Caml_array.caml_array_get(match[0], ntrue - 1 | 0) : /* false */0)) {
    return /* Ok */0;
  } else {
    return /* Error */[""];
  }
}

var eval_range = /* :: */[
  /* tuple */[
    /* Range */Block.__(0, [
        10,
        22
      ]),
    /* Short */0
  ],
  /* [] */0
];

function prepare_build(i) {
  return i;
}

function run_build(i) {
  var nodeC = [1];
  var sz_1 = [8191];
  var htab = [Caml_array.caml_make_vect(sz_1[0] + 1 | 0, /* [] */0)];
  var n_items = [0];
  var hashVal = function (x, y, v) {
    return ((x << 1) + y | 0) + (v << 2) | 0;
  };
  var resize = function (newSize) {
    var arr = htab[0];
    var newSz_1 = newSize - 1 | 0;
    var newArr = Caml_array.caml_make_vect(newSize, /* [] */0);
    var copyBucket = function (_bucket) {
      while(true) {
        var bucket = _bucket;
        if (bucket) {
          var n = bucket[0];
          if (typeof n === "number") {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "bdd.ml",
                    55,
                    15
                  ]
                ];
          } else {
            var ind = hashVal(getId(n[0]), getId(n[3]), n[1]) & newSz_1;
            Caml_array.caml_array_set(newArr, ind, /* :: */[
                  n,
                  Caml_array.caml_array_get(newArr, ind)
                ]);
            _bucket = bucket[1];
            continue ;
            
          }
        } else {
          return /* () */0;
        }
      };
    };
    for(var n = 0 ,n_finish = sz_1[0]; n <= n_finish; ++n){
      copyBucket(Caml_array.caml_array_get(arr, n));
    }
    htab[0] = newArr;
    sz_1[0] = newSz_1;
    return /* () */0;
  };
  var insert = function (idl, idh, v, ind, bucket, newNode) {
    if (n_items[0] <= sz_1[0]) {
      Caml_array.caml_array_set(htab[0], ind, /* :: */[
            newNode,
            bucket
          ]);
      n_items[0] = n_items[0] + 1 | 0;
      return /* () */0;
    } else {
      resize((sz_1[0] + sz_1[0] | 0) + 2 | 0);
      var ind$1 = hashVal(idl, idh, v) & sz_1[0];
      return Caml_array.caml_array_set(htab[0], ind$1, /* :: */[
                  newNode,
                  Caml_array.caml_array_get(htab[0], ind$1)
                ]);
    }
  };
  var mkNode = function (low, v, high) {
    var idl = getId(low);
    var idh = getId(high);
    if (idl === idh) {
      return low;
    } else {
      var ind = hashVal(idl, idh, v) & sz_1[0];
      var bucket = Caml_array.caml_array_get(htab[0], ind);
      var _b = bucket;
      while(true) {
        var b = _b;
        if (b) {
          var n = b[0];
          if (typeof n === "number") {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "bdd.ml",
                    100,
                    17
                  ]
                ];
          } else if (v === n[1] && idl === getId(n[0]) && idh === getId(n[3])) {
            return n;
          } else {
            _b = b[1];
            continue ;
            
          }
        } else {
          var n_002 = (nodeC[0] = nodeC[0] + 1 | 0, nodeC[0]);
          var n$1 = /* Node */[
            low,
            v,
            n_002,
            high
          ];
          insert(getId(low), getId(high), v, ind, bucket, n$1);
          return n$1;
        }
      };
    }
  };
  var cmpVar = function (x, y) {
    if (x < y) {
      return /* LESS */0;
    } else if (x > y) {
      return /* GREATER */2;
    } else {
      return /* EQUAL */1;
    }
  };
  var andslot1 = Caml_array.caml_make_vect(1999, 0);
  var andslot2 = Caml_array.caml_make_vect(1999, 0);
  var andslot3 = Caml_array.caml_make_vect(1999, /* Zero */1);
  var notslot1 = Caml_array.caml_make_vect(1999, 0);
  var notslot2 = Caml_array.caml_make_vect(1999, /* One */0);
  var hash = function (x, y) {
    return ((x << 1) + y | 0) % 1999;
  };
  var not = function (n) {
    if (typeof n === "number") {
      if (n !== 0) {
        return /* One */0;
      } else {
        return /* Zero */1;
      }
    } else {
      var id = n[2];
      var h = id % 1999;
      if (id === Caml_array.caml_array_get(notslot1, h)) {
        return Caml_array.caml_array_get(notslot2, h);
      } else {
        var f = mkNode(not(n[0]), n[1], not(n[3]));
        Caml_array.caml_array_set(notslot1, h, id);
        Caml_array.caml_array_set(notslot2, h, f);
        return f;
      }
    }
  };
  var and2 = function (n1, n2) {
    if (typeof n1 === "number") {
      if (n1 !== 0) {
        return /* Zero */1;
      } else {
        return n2;
      }
    } else {
      var r1 = n1[3];
      var i1 = n1[2];
      var v1 = n1[1];
      var l1 = n1[0];
      if (typeof n2 === "number") {
        if (n2 !== 0) {
          return /* Zero */1;
        } else {
          return n1;
        }
      } else {
        var r2 = n2[3];
        var i2 = n2[2];
        var v2 = n2[1];
        var l2 = n2[0];
        var h = hash(i1, i2);
        if (i1 === Caml_array.caml_array_get(andslot1, h) && i2 === Caml_array.caml_array_get(andslot2, h)) {
          return Caml_array.caml_array_get(andslot3, h);
        } else {
          var match = cmpVar(v1, v2);
          var f;
          switch (match) {
            case 0 : 
                f = mkNode(and2(l1, n2), v1, and2(r1, n2));
                break;
            case 1 : 
                f = mkNode(and2(l1, l2), v1, and2(r1, r2));
                break;
            case 2 : 
                f = mkNode(and2(n1, l2), v2, and2(n1, r2));
                break;
            
          }
          Caml_array.caml_array_set(andslot1, h, i1);
          Caml_array.caml_array_set(andslot2, h, i2);
          Caml_array.caml_array_set(andslot3, h, f);
          return f;
        }
      }
    }
  };
  var xor = function (n1, n2) {
    if (typeof n1 === "number") {
      if (n1 !== 0) {
        return n2;
      } else {
        return not(n2);
      }
    } else {
      var r1 = n1[3];
      var i1 = n1[2];
      var v1 = n1[1];
      var l1 = n1[0];
      if (typeof n2 === "number") {
        if (n2 !== 0) {
          return n1;
        } else {
          return not(n1);
        }
      } else {
        var r2 = n2[3];
        var i2 = n2[2];
        var v2 = n2[1];
        var l2 = n2[0];
        var h = hash(i1, i2);
        if (i1 === Caml_array.caml_array_get(andslot1, h) && i2 === Caml_array.caml_array_get(andslot2, h)) {
          return Caml_array.caml_array_get(andslot3, h);
        } else {
          var match = cmpVar(v1, v2);
          var f;
          switch (match) {
            case 0 : 
                f = mkNode(xor(l1, n2), v1, xor(r1, n2));
                break;
            case 1 : 
                f = mkNode(xor(l1, l2), v1, xor(r1, r2));
                break;
            case 2 : 
                f = mkNode(xor(n1, l2), v2, xor(n1, r2));
                break;
            
          }
          Caml_array.caml_array_set(andslot1, h, i1);
          Caml_array.caml_array_set(andslot2, h, i2);
          Caml_array.caml_array_set(andslot3, h, f);
          return f;
        }
      }
    }
  };
  var n = i;
  var h = function (i, j) {
    if (i === j) {
      return mkNode(/* Zero */1, i, /* One */0);
    } else {
      return xor(and2(not(mkNode(/* Zero */1, j, /* One */0)), h(i, j - 1 | 0)), and2(mkNode(/* Zero */1, j, /* One */0), g(i, j - 1 | 0)));
    }
  };
  var g = function (i, j) {
    if (i === j) {
      return mkNode(/* Zero */1, i, /* One */0);
    } else {
      return xor(and2(not(mkNode(/* Zero */1, i, /* One */0)), h(i + 1 | 0, j)), and2(mkNode(/* Zero */1, i, /* One */0), g(i + 1 | 0, j)));
    }
  };
  return h(0, n - 1 | 0);
}

function check_build(i, bdd) {
  var vars = random_vars(i);
  var ntrue = count_true(vars);
  var result = $$eval(bdd, vars);
  if (Caml_obj.caml_equal(result, ntrue > 0 ? Caml_array.caml_array_get(vars, ntrue - 1 | 0) : /* false */0)) {
    return /* Ok */0;
  } else {
    return /* Error */[""];
  }
}

var build_range = /* :: */[
  /* tuple */[
    /* Range */Block.__(0, [
        10,
        20
      ]),
    /* Long */1
  ],
  /* [] */0
];

var functions_000 = /* tuple */[
  "eval",
  /* Int */Block.__(1, [/* tuple */[
        run_eval,
        prepare_eval,
        check_eval,
        eval_range
      ]])
];

var functions_001 = /* :: */[
  /* tuple */[
    "build",
    /* Int */Block.__(1, [/* tuple */[
          run_build,
          prepare_build,
          check_build,
          build_range
        ]])
  ],
  /* [] */0
];

var functions = /* :: */[
  functions_000,
  functions_001
];

Micro_bench_types.add(functions);

var config = Micro_bench_run.Config[/* parse */1](/* () */0);

if (typeof config === "number") {
  Micro_bench_run.run(/* Some */[/* Some */[config]], Micro_bench_types.functions(/* () */0));
} else if (config[0] !== 4103979) {
  Micro_bench_run.run(/* Some */[/* Some */[config]], Micro_bench_types.functions(/* () */0));
} else {
  var conf = config[1];
  Fixture.run_n_times(1, (function () {
          var newrecord = conf.slice();
          return Micro_bench_run.run(/* Some */[/* Some */[/* `Run */[
                          4103979,
                          (newrecord[/* number_of_different_values */5] = 20, newrecord)
                        ]]], Micro_bench_types.functions(/* () */0));
        }));
}

exports.$$eval        = $$eval;
exports.getId         = getId;
exports.Build         = Build;
exports.random_vars   = random_vars;
exports.count_true    = count_true;
exports.prepare_eval  = prepare_eval;
exports.run_eval      = run_eval;
exports.check_eval    = check_eval;
exports.eval_range    = eval_range;
exports.prepare_build = prepare_build;
exports.run_build     = run_build;
exports.check_build   = check_build;
exports.build_range   = build_range;
exports.functions     = functions;
/*  Not a pure module */
