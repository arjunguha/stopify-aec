// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var Arg        = require("bs-platform/lib/js/arg.js");
var $$Set      = require("bs-platform/lib/js/set.js");
var Sys        = require("bs-platform/lib/js/sys.js");
var List       = require("bs-platform/lib/js/list.js");
var $$Array    = require("bs-platform/lib/js/array.js");
var Block      = require("bs-platform/lib/js/block.js");
var Curry      = require("bs-platform/lib/js/curry.js");
var Js_exn     = require("bs-platform/lib/js/js_exn.js");
var Printf     = require("bs-platform/lib/js/printf.js");
var $$String   = require("bs-platform/lib/js/string.js");
var Caml_gc    = require("bs-platform/lib/js/caml_gc.js");
var Caml_obj   = require("bs-platform/lib/js/caml_obj.js");
var Caml_sys   = require("bs-platform/lib/js/caml_sys.js");
var Printexc   = require("bs-platform/lib/js/printexc.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function compare_cost(c1, c2) {
  switch (c1) {
    case 0 : 
        if (c2 !== 0) {
          return -1;
        } else {
          return 0;
        }
    case 1 : 
        switch (c2) {
          case 0 : 
              return 1;
          case 1 : 
              return 0;
          case 2 : 
              return -1;
          
        }
        break;
    case 2 : 
        switch (c2) {
          case 0 : 
          case 1 : 
              return 1;
          case 2 : 
              return 0;
          
        }
        break;
    
  }
}

function print_list(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var t = param[1];
      var s = param[0];
      if (t) {
        Pervasives.print_string(s);
        Pervasives.print_char(/* " " */32);
        _param = t;
        continue ;
        
      } else {
        console.log(s);
        return /* () */0;
      }
    } else {
      return /* () */0;
    }
  };
}

function prerr_list(_param) {
  while(true) {
    var param = _param;
    if (param) {
      var t = param[1];
      var s = param[0];
      if (t) {
        Pervasives.prerr_string(s);
        Pervasives.prerr_char(/* " " */32);
        _param = t;
        continue ;
        
      } else {
        console.error(s);
        return /* () */0;
      }
    } else {
      return /* () */0;
    }
  };
}

var include = $$Set.Make([$$String.compare]);

var empty = include[0];

var add = include[3];

var singleton = include[4];

function of_list(l) {
  return List.fold_right(add, l, empty);
}

var StringSet_001 = /* is_empty */include[1];

var StringSet_002 = /* mem */include[2];

var StringSet_005 = /* remove */include[5];

var StringSet_006 = /* union */include[6];

var StringSet_007 = /* inter */include[7];

var StringSet_008 = /* diff */include[8];

var StringSet_009 = /* compare */include[9];

var StringSet_010 = /* equal */include[10];

var StringSet_011 = /* subset */include[11];

var StringSet_012 = /* iter */include[12];

var StringSet_013 = /* fold */include[13];

var StringSet_014 = /* for_all */include[14];

var StringSet_015 = /* exists */include[15];

var StringSet_016 = /* filter */include[16];

var StringSet_017 = /* partition */include[17];

var StringSet_018 = /* cardinal */include[18];

var StringSet_019 = /* elements */include[19];

var StringSet_020 = /* min_elt */include[20];

var StringSet_021 = /* max_elt */include[21];

var StringSet_022 = /* choose */include[22];

var StringSet_023 = /* split */include[23];

var StringSet_024 = /* find */include[24];

var StringSet = /* module */[
  /* empty */empty,
  StringSet_001,
  StringSet_002,
  /* add */add,
  /* singleton */singleton,
  StringSet_005,
  StringSet_006,
  StringSet_007,
  StringSet_008,
  StringSet_009,
  StringSet_010,
  StringSet_011,
  StringSet_012,
  StringSet_013,
  StringSet_014,
  StringSet_015,
  StringSet_016,
  StringSet_017,
  StringSet_018,
  StringSet_019,
  StringSet_020,
  StringSet_021,
  StringSet_022,
  StringSet_023,
  StringSet_024,
  /* of_list */of_list
];

var iround_lbound = Pervasives.min_int;

var iround_ubound = Pervasives.min(Pervasives.max_int, Math.pow(2.0, 62.0) - 512);

function iround_towards_zero_exn(t) {
  if (t >= iround_lbound && t <= iround_ubound) {
    return t | 0;
  } else {
    return Pervasives.invalid_arg("Float.iround_towards_zero_exn: argument (" + (Pervasives.string_of_float(t) + ") is out of range or NaN"));
  }
}

var Float = /* module */[
  /* iround_lbound */iround_lbound,
  /* iround_ubound */iround_ubound,
  /* iround_towards_zero_exn */iround_towards_zero_exn
];

function now() {
  return Caml_sys.caml_sys_time(/* () */0);
}

function diff(t1, t2) {
  return t1 - t2;
}

function of_sec(v) {
  return v;
}

function to_float(v) {
  return v;
}

function to_ns(v) {
  return v * 1E9;
}

function to_string(v) {
  return Pervasives.string_of_float(v) + "s";
}

var Time_001 = /* Span */[
  of_sec,
  to_float,
  to_ns,
  to_string
];

var Time = /* module */[
  /* now */now,
  Time_001,
  /* diff */diff
];

var time_quota = Curry._1(Time_001[/* of_sec */0], 10.0);

var Defaults = /* module */[
  /* geometric_scale */1.01,
  /* stabilize_gc_between_runs : false */0,
  /* no_compactions : false */0,
  /* time_quota_float */10.0,
  /* time_quota */time_quota,
  /* number_of_different_values */1,
  /* maximal_cost : Short */0,
  /* selection : None */0,
  /* test_only : false */0,
  /* verbosity : Low */3804276
];

function create($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, $staropt$star$4, $staropt$star$5, $staropt$star$6, $staropt$star$7, $staropt$star$8, output_file, _) {
  var verbosity = $staropt$star ? $staropt$star[0] : /* Low */3804276;
  var no_compactions = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
  var time_quota$1 = $staropt$star$2 ? $staropt$star$2[0] : time_quota;
  var sampling_type = $staropt$star$3 ? $staropt$star$3[0] : /* `Geometric */[
      588000097,
      1.01
    ];
  var stabilize_gc_between_runs = $staropt$star$4 ? $staropt$star$4[0] : /* false */0;
  var number_of_different_values = $staropt$star$5 ? $staropt$star$5[0] : 1;
  var maximal_cost = $staropt$star$6 ? $staropt$star$6[0] : /* Short */0;
  var selection = $staropt$star$7 ? $staropt$star$7[0] : /* None */0;
  var test_only = $staropt$star$8 ? $staropt$star$8[0] : /* false */0;
  return /* record */[
          /* verbosity */verbosity,
          /* no_compactions */no_compactions,
          /* time_quota */time_quota$1,
          /* sampling_type */sampling_type,
          /* stabilize_gc_between_runs */stabilize_gc_between_runs,
          /* number_of_different_values */number_of_different_values,
          /* maximal_cost */maximal_cost,
          /* selection */selection,
          /* test_only */test_only,
          /* output_file */output_file
        ];
}

function parse() {
  var verbosity = [/* None */0];
  var no_compactions = [/* None */0];
  var time_quota = [/* None */0];
  var sampling_type = [/* None */0];
  var stabilize_gc_between_runs = [/* None */0];
  var number_of_different_values = [/* None */0];
  var maximal_cost = [/* Short */0];
  var test_only = [/* None */0];
  var set = function (r, v) {
    return /* Unit */Block.__(0, [(function () {
                  r[0] = /* Some */[v];
                  return /* () */0;
                })]);
  };
  var set_quota = /* Float */Block.__(8, [(function (v) {
          time_quota[0] = /* Some */[Curry._1(Time_001[/* of_sec */0], v)];
          return /* () */0;
        })]);
  var set_sampling = /* Int */Block.__(6, [(function (i) {
          sampling_type[0] = /* Some */[/* `Linear */[
              557106693,
              i
            ]];
          return /* () */0;
        })]);
  var set_int = function (r) {
    return /* Int */Block.__(6, [(function (i) {
                  r[0] = /* Some */[i];
                  return /* () */0;
                })]);
  };
  var set_cost = function (c) {
    return /* Unit */Block.__(0, [(function () {
                  if (compare_cost(maximal_cost[0], c) < 0) {
                    maximal_cost[0] = c;
                    return /* () */0;
                  } else {
                    return 0;
                  }
                })]);
  };
  var set_float = function (r) {
    return /* String */Block.__(4, [(function (i) {
                  r[0] = /* Some */[i];
                  return /* () */0;
                })]);
  };
  var list = [/* false */0];
  var raw_list = [/* false */0];
  var count = [/* false */0];
  var output_file = [/* None */0];
  var selection = [/* None */0];
  var spec_000 = /* tuple */[
    "-v",
    set(verbosity, /* High */803693442),
    " high verbosity"
  ];
  var spec_001 = /* :: */[
    /* tuple */[
      "--no-compaction",
      set(no_compactions, /* true */1),
      " no compaction"
    ],
    /* :: */[
      /* tuple */[
        "--time-quota",
        set_quota,
        "t time_quota"
      ],
      /* :: */[
        /* tuple */[
          "-q",
          set_quota,
          " alias of --time-quota"
        ],
        /* :: */[
          /* tuple */[
            "--linear-sampling",
            set_sampling,
            "n set linear sampling type with the given step size"
          ],
          /* :: */[
            /* tuple */[
              "--stabilize-gc",
              set(stabilize_gc_between_runs, /* true */1),
              " stabilize gc between runs"
            ],
            /* :: */[
              /* tuple */[
                "--different-values",
                set_int(number_of_different_values),
                "n number of different values"
              ],
              /* :: */[
                /* tuple */[
                  "-n",
                  set_int(number_of_different_values),
                  " alias of --different-values"
                ],
                /* :: */[
                  /* tuple */[
                    "--long",
                    set_cost(/* Long */1),
                    " allow running long test"
                  ],
                  /* :: */[
                    /* tuple */[
                      "--longer",
                      set_cost(/* Longer */2),
                      " allow running longer test"
                    ],
                    /* :: */[
                      /* tuple */[
                        "--test",
                        set(test_only, /* true */1),
                        " don't run benchmarks"
                      ],
                      /* :: */[
                        /* tuple */[
                          "-t",
                          set(test_only, /* true */1),
                          " alias of --test"
                        ],
                        /* :: */[
                          /* tuple */[
                            "--list",
                            /* Set */Block.__(2, [list]),
                            " list available benchmarks"
                          ],
                          /* :: */[
                            /* tuple */[
                              "-l",
                              /* Set */Block.__(2, [list]),
                              " alias of --list"
                            ],
                            /* :: */[
                              /* tuple */[
                                "--raw-list",
                                /* Set */Block.__(2, [raw_list]),
                                " list available benchmarks"
                              ],
                              /* :: */[
                                /* tuple */[
                                  "--count",
                                  /* Set */Block.__(2, [count]),
                                  " print number of benchmarks"
                                ],
                                /* :: */[
                                  /* tuple */[
                                    "-o",
                                    set_float(output_file),
                                    " set output file"
                                  ],
                                  /* [] */0
                                ]
                              ]
                            ]
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ];
  var spec = /* :: */[
    spec_000,
    spec_001
  ];
  var doc = Sys.executable_name + " [options] [selection]";
  Arg.parse(Arg.align(/* None */0, spec), (function (s) {
          var match = selection[0];
          if (match) {
            selection[0] = /* Some */[Curry._2(add, s, match[0])];
            return /* () */0;
          } else {
            selection[0] = /* Some */[Curry._1(singleton, s)];
            return /* () */0;
          }
        }), doc);
  if (count[0]) {
    return /* Count */-577719121;
  } else if (list[0] || raw_list[0]) {
    return /* `List */[
            848054398,
            raw_list[0]
          ];
  } else {
    return /* `Run */[
            4103979,
            create(verbosity[0], no_compactions[0], time_quota[0], sampling_type[0], stabilize_gc_between_runs[0], number_of_different_values[0], /* Some */[maximal_cost[0]], /* Some */[selection[0]], test_only[0], output_file[0], /* () */0)
          ];
  }
}

var Config = /* module */[
  /* create */create,
  /* parse */parse
];

function create$1() {
  return /* record */[
          /* runs */0,
          /* cycles */0,
          /* nanos */0,
          /* compactions */0,
          /* minor_allocated */0,
          /* major_allocated */0,
          /* promoted */0,
          /* major_collections */0,
          /* minor_collections */0
        ];
}

function output(oc, m) {
  var out = function (i) {
    Pervasives.output_string(oc, Pervasives.string_of_int(i));
    return Pervasives.output_char(oc, /* " " */32);
  };
  out(m[/* runs */0]);
  out(m[/* cycles */1]);
  out(m[/* nanos */2]);
  out(m[/* compactions */3]);
  out(m[/* minor_allocated */4]);
  out(m[/* major_allocated */5]);
  out(m[/* promoted */6]);
  out(m[/* major_collections */7]);
  out(m[/* minor_collections */8]);
  return Pervasives.output_char(oc, /* "\n" */10);
}

var Measurement_sample = /* module */[
  /* create */create$1,
  /* output */output
];

function create$2(name, group, parameter, largest_run, sample_count, samples) {
  return /* record */[
          /* name */name,
          /* group */group,
          /* parameter */parameter,
          /* largest_run */largest_run,
          /* sample_count */sample_count,
          /* samples */samples
        ];
}

function output$1(oc, t) {
  Pervasives.output_string(oc, t[/* name */0]);
  Pervasives.output_char(oc, /* "\n" */10);
  var match = t[/* group */1];
  if (match) {
    Pervasives.output_string(oc, "group: ");
    Pervasives.output_string(oc, match[0]);
    Pervasives.output_char(oc, /* "\n" */10);
  }
  var match$1 = t[/* parameter */2];
  if (match$1) {
    Pervasives.output_string(oc, "parameter: ");
    Pervasives.output_string(oc, Pervasives.string_of_int(match$1[0]));
    Pervasives.output_char(oc, /* "\n" */10);
  }
  Pervasives.output_char(oc, /* "\n" */10);
  for(var i = 0 ,i_finish = t[/* sample_count */4] - 1 | 0; i <= i_finish; ++i){
    output(oc, Caml_array.caml_array_get(t[/* samples */5], i));
  }
  return Pervasives.output_char(oc, /* "\n" */10);
}

var Measurement = /* module */[
  /* create */create$2,
  /* output */output$1
];

function stabilize_gc() {
  var _failsafe = 10;
  var _last_heap_live_words = 0;
  while(true) {
    var last_heap_live_words = _last_heap_live_words;
    var failsafe = _failsafe;
    if (failsafe <= 0) {
      Pervasives.failwith("unable to stabilize the number of live words in the major heap");
    }
    Caml_gc.caml_gc_compaction(/* () */0);
    var stat = Caml_gc.caml_gc_stat(/* () */0);
    if (stat[/* live_words */7] !== last_heap_live_words) {
      _last_heap_live_words = stat[/* live_words */7];
      _failsafe = failsafe - 1 | 0;
      continue ;
      
    } else {
      return 0;
    }
  };
}

function pick_any(n) {
  var num = function (k) {
    return Caml_int32.imul(k, k) % 4028033;
  };
  var rd = function (n0) {
    var n1 = num(n0);
    var n2 = num(n1);
    var n3 = num(n2);
    var n4 = num(n3);
    return /* tuple */[
            ((n1 % 16 + (n2 % 16 << 4) | 0) + (n3 % 16 << 8) | 0) + (n4 % 16 << 12) | 0,
            n4
          ];
  };
  var aux = function (n, k) {
    if (n) {
      var match = rd(k);
      return /* :: */[
              match[0] - 32768 | 0,
              aux(n - 1 | 0, match[1])
            ];
    } else {
      return /* [] */0;
    }
  };
  return aux(n, 42);
}

function range(x, y) {
  if (x > y) {
    return /* [] */0;
  } else {
    return /* :: */[
            x,
            range(x + 1 | 0, y)
          ];
  }
}

function pick_range(n, param) {
  var y = param[1];
  var x = param[0];
  if (n !== 0) {
    if (n !== 1) {
      var match = x < y ? /* tuple */[
          x,
          y
        ] : /* tuple */[
          y,
          x
        ];
      var y$1 = match[1];
      var x$1 = match[0];
      var d = y$1 - x$1 | 0;
      if (d < n) {
        return range(x$1, y$1);
      } else {
        var v = Caml_int32.div(d, n - 1 | 0);
        return List.map((function (i) {
                      return x$1 + Caml_int32.imul(i, v) | 0;
                    }), range(0, n - 1 | 0));
      }
    } else {
      return /* :: */[
              x,
              /* [] */0
            ];
    }
  } else {
    return /* [] */0;
  }
}

function pick_list(n, l) {
  if (n <= 0 || !l) {
    return /* [] */0;
  } else {
    return /* :: */[
            l[0],
            pick_list(n - 1 | 0, l[1])
          ];
  }
}

function pick_values(n, param) {
  if (typeof param === "number") {
    return pick_any(n);
  } else if (param.tag) {
    return pick_list(n, param[0]);
  } else {
    return pick_range(n, /* tuple */[
                param[0],
                param[1]
              ]);
  }
}

function pick(n, max_cost, l) {
  var l$1 = List.filter((function (param) {
            return +(compare_cost(param[1], max_cost) <= 0);
          }))(l);
  var l$2 = List.sort((function (param, param$1) {
          return compare_cost(param[1], param$1[1]);
        }), l$1);
  var l$3 = List.map((function (prim) {
          return prim[0];
        }), l$2);
  var l$4 = pick_list(n, l$3);
  var len = List.length(l$4);
  if (len) {
    var match = n <= len ? /* tuple */[
        1,
        0
      ] : /* tuple */[
        Caml_int32.div(n, len),
        Caml_int32.mod_(n, len)
      ];
    var r = match[1];
    var q = match[0];
    var a = $$Array.mapi((function (i, range) {
            var n = i < r ? q + 1 | 0 : q;
            return pick_values(n, range);
          }), $$Array.of_list(l$4));
    return List.concat($$Array.to_list(a));
  } else {
    return /* [] */0;
  }
}

var errors = [/* false */0];

function in_selection(_, _$1) {
  return /* true */1;
}

function test(param, item) {
  var max_cost = param[/* maximal_cost */6];
  var n = param[/* number_of_different_values */5];
  var verbosity = param[/* verbosity */0];
  var run_unit = function (name, f, test) {
    if (verbosity === /* High */803693442) {
      print_list(/* :: */[
            "running test",
            /* :: */[
              name,
              /* [] */0
            ]
          ]);
    }
    try {
      var match = Curry._1(test, Curry._1(f, /* () */0));
      if (match) {
        errors[0] = /* true */1;
        return prerr_list(/* :: */[
                    "test",
                    /* :: */[
                      name,
                      /* :: */[
                        "failed with message",
                        /* :: */[
                          match[0],
                          /* [] */0
                        ]
                      ]
                    ]
                  ]);
      } else {
        return /* () */0;
      }
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      return prerr_list(/* :: */[
                  "test",
                  /* :: */[
                    name,
                    /* :: */[
                      "failed with exception",
                      /* :: */[
                        Printexc.to_string(exn),
                        /* [] */0
                      ]
                    ]
                  ]
                ]);
    }
  };
  var run_int = function (name, f, prepare, test, costs) {
    var aux = function (v) {
      if (verbosity === /* High */803693442) {
        print_list(/* :: */[
              "running test",
              /* :: */[
                name,
                /* :: */[
                  "with argument",
                  /* :: */[
                    Pervasives.string_of_int(v),
                    /* [] */0
                  ]
                ]
              ]
            ]);
      }
      try {
        var match = Curry._2(test, v, Curry._1(f, Curry._1(prepare, v)));
        if (match) {
          errors[0] = /* true */1;
          return prerr_list(/* :: */[
                      "test",
                      /* :: */[
                        name,
                        /* :: */[
                          "with parameter",
                          /* :: */[
                            Pervasives.string_of_int(v),
                            /* :: */[
                              "failed with message",
                              /* :: */[
                                match[0],
                                /* [] */0
                              ]
                            ]
                          ]
                        ]
                      ]
                    ]);
        } else {
          return /* () */0;
        }
      }
      catch (raw_exn){
        var exn = Js_exn.internalToOCamlException(raw_exn);
        return prerr_list(/* :: */[
                    "test",
                    /* :: */[
                      name,
                      /* :: */[
                        "with parameter",
                        /* :: */[
                          Pervasives.string_of_int(v),
                          /* :: */[
                            "failed with exception",
                            /* :: */[
                              Printexc.to_string(exn),
                              /* [] */0
                            ]
                          ]
                        ]
                      ]
                    ]
                  ]);
      }
    };
    return List.iter(aux, pick(n, max_cost, costs));
  };
  var match = item[1];
  var name = item[0];
  switch (match.tag | 0) {
    case 0 : 
        var match$1 = match[0];
        if (compare_cost(match$1[2], max_cost) <= 0 && /* true */1) {
          return run_unit(name, match$1[0], match$1[1]);
        } else {
          return 0;
        }
    case 1 : 
        var match$2 = match[0];
        return run_int(name, match$2[0], match$2[1], match$2[2], match$2[3]);
    case 2 : 
        var match$3 = match[0];
        var test$1 = match$3[1];
        if (compare_cost(match$3[2], max_cost) <= 0 && /* true */1) {
          var aux = function (param) {
            var name$1 = name + ("." + param[0]);
            return run_unit(name$1, param[1], test$1);
          };
          return List.iter(aux, match$3[0]);
        } else {
          return 0;
        }
        break;
    case 3 : 
        var match$4 = match[0];
        var costs = match$4[3];
        var test$2 = match$4[2];
        var prepare = match$4[1];
        var aux$1 = function (param) {
          var name$1 = name + ("." + param[0]);
          return run_int(name$1, param[1], prepare, test$2, costs);
        };
        return List.iter(aux$1, match$4[0]);
    
  }
}

function string_of_cost(param) {
  switch (param) {
    case 0 : 
        return "short";
    case 1 : 
        return "long";
    case 2 : 
        return "longer";
    
  }
}

function string_of_range(param) {
  if (typeof param === "number") {
    return "any";
  } else if (param.tag) {
    return "[" + ($$String.concat("; ", List.map(Pervasives.string_of_int, param[0])) + "]");
  } else {
    return "[" + (Pervasives.string_of_int(param[0]) + (" ... " + (Pervasives.string_of_int(param[1]) + "]")));
  }
}

function list(output, l) {
  return List.iter((function (param) {
                var match = param[1];
                var name = param[0];
                switch (match.tag | 0) {
                  case 0 : 
                      return Curry._2(Printf.fprintf(output, /* Format */[
                                      /* String_literal */Block.__(11, [
                                          "  ",
                                          /* String */Block.__(2, [
                                              /* No_padding */0,
                                              /* String_literal */Block.__(11, [
                                                  ": ",
                                                  /* String */Block.__(2, [
                                                      /* No_padding */0,
                                                      /* Char_literal */Block.__(12, [
                                                          /* "\n" */10,
                                                          /* End_of_format */0
                                                        ])
                                                    ])
                                                ])
                                            ])
                                        ]),
                                      "  %s: %s\n"
                                    ]), name, string_of_cost(match[0][2]));
                  case 1 : 
                      Curry._1(Printf.fprintf(output, /* Format */[
                                /* String_literal */Block.__(11, [
                                    "  ",
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* String_literal */Block.__(11, [
                                            ":\n",
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ]),
                                "  %s:\n"
                              ]), name);
                      return List.iter((function (param) {
                                    return Curry._2(Printf.fprintf(output, /* Format */[
                                                    /* String_literal */Block.__(11, [
                                                        "    ",
                                                        /* String */Block.__(2, [
                                                            /* No_padding */0,
                                                            /* String_literal */Block.__(11, [
                                                                ": ",
                                                                /* String */Block.__(2, [
                                                                    /* No_padding */0,
                                                                    /* Char_literal */Block.__(12, [
                                                                        /* "\n" */10,
                                                                        /* End_of_format */0
                                                                      ])
                                                                  ])
                                                              ])
                                                          ])
                                                      ]),
                                                    "    %s: %s\n"
                                                  ]), string_of_cost(param[1]), string_of_range(param[0]));
                                  }), match[0][3]);
                  case 2 : 
                      var match$1 = match[0];
                      Curry._2(Printf.fprintf(output, /* Format */[
                                /* String_literal */Block.__(11, [
                                    "  ",
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* String_literal */Block.__(11, [
                                            ": ",
                                            /* String */Block.__(2, [
                                                /* No_padding */0,
                                                /* Char_literal */Block.__(12, [
                                                    /* "\n" */10,
                                                    /* End_of_format */0
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ]),
                                "  %s: %s\n"
                              ]), name, string_of_cost(match$1[2]));
                      return List.iter((function (param) {
                                    return Curry._1(Printf.fprintf(output, /* Format */[
                                                    /* String_literal */Block.__(11, [
                                                        "  - ",
                                                        /* String */Block.__(2, [
                                                            /* No_padding */0,
                                                            /* Char_literal */Block.__(12, [
                                                                /* "\n" */10,
                                                                /* End_of_format */0
                                                              ])
                                                          ])
                                                      ]),
                                                    "  - %s\n"
                                                  ]), param[0]);
                                  }), match$1[0]);
                  case 3 : 
                      var match$2 = match[0];
                      Curry._1(Printf.fprintf(output, /* Format */[
                                /* String_literal */Block.__(11, [
                                    "  ",
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* String_literal */Block.__(11, [
                                            ":\n",
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ]),
                                "  %s:\n"
                              ]), name);
                      List.iter((function (param) {
                              return Curry._2(Printf.fprintf(output, /* Format */[
                                              /* String_literal */Block.__(11, [
                                                  "    ",
                                                  /* String */Block.__(2, [
                                                      /* No_padding */0,
                                                      /* String_literal */Block.__(11, [
                                                          ": ",
                                                          /* String */Block.__(2, [
                                                              /* No_padding */0,
                                                              /* Char_literal */Block.__(12, [
                                                                  /* "\n" */10,
                                                                  /* End_of_format */0
                                                                ])
                                                            ])
                                                        ])
                                                    ])
                                                ]),
                                              "    %s: %s\n"
                                            ]), string_of_cost(param[1]), string_of_range(param[0]));
                            }), match$2[3]);
                      return List.iter((function (param) {
                                    return Curry._1(Printf.fprintf(output, /* Format */[
                                                    /* String_literal */Block.__(11, [
                                                        "  - ",
                                                        /* String */Block.__(2, [
                                                            /* No_padding */0,
                                                            /* Char_literal */Block.__(12, [
                                                                /* "\n" */10,
                                                                /* End_of_format */0
                                                              ])
                                                          ])
                                                      ]),
                                                    "  - %s\n"
                                                  ]), param[0]);
                                  }), match$2[0]);
                  
                }
              }), l);
}

var Tester = /* module */[
  /* pick_any */pick_any,
  /* range */range,
  /* pick_range */pick_range,
  /* pick_list */pick_list,
  /* pick_values */pick_values,
  /* pick */pick,
  /* errors */errors,
  /* in_selection */in_selection,
  /* test */test,
  /* string_of_cost */string_of_cost,
  /* string_of_range */string_of_range,
  /* list */list
];

function exceeded_allowed_time(allowed_time_span, t1) {
  var t2 = Caml_sys.caml_sys_time(/* () */0);
  return Caml_obj.caml_greaterthan(t2 - t1, allowed_time_span);
}

function run_tests(config, functions) {
  return List.iter((function (param) {
                return test(config, param);
              }), functions);
}

function run_all(config, functions) {
  run_tests(config, functions);
  if (errors[0]) {
    return Pervasives.exit(1);
  } else {
    return /* [] */0;
  }
}

function with_output(funct, output_file) {
  var output = output_file ? Pervasives.open_out(output_file[0]) : Pervasives.stdout;
  try {
    return Curry._1(funct, output);
  }
  catch (e){
    Pervasives.close_out(output);
    throw e;
  }
}

function run($staropt$star, functions) {
  var conf = $staropt$star ? $staropt$star[0] : /* Some */[parse(/* () */0)];
  if (conf) {
    var match = conf[0];
    if (typeof match === "number") {
      var f = function (output) {
        return Curry._1(Printf.fprintf(output, /* Format */[
                        /* Int */Block.__(4, [
                            /* Int_i */3,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* End_of_format */0
                          ]),
                        "%i"
                      ]), List.fold_left((function (acc, param) {
                          var funs = param[1];
                          switch (funs.tag | 0) {
                            case 0 : 
                            case 1 : 
                                return acc + 1 | 0;
                            case 2 : 
                            case 3 : 
                                return acc + List.length(funs[0][0]) | 0;
                            
                          }
                        }), 0, functions));
      };
      return with_output(f, /* None */0);
    } else if (match[0] >= 848054398) {
      var raw = match[1];
      var f$1 = function (output) {
        if (raw) {
          return List.iter((function (param) {
                        return Curry._1(Printf.fprintf(output, /* Format */[
                                        /* String */Block.__(2, [
                                            /* No_padding */0,
                                            /* Char_literal */Block.__(12, [
                                                /* "\n" */10,
                                                /* End_of_format */0
                                              ])
                                          ]),
                                        "%s\n"
                                      ]), param[0]);
                      }), functions);
        } else {
          Printf.fprintf(output, /* Format */[
                /* String_literal */Block.__(11, [
                    "benchmarks:\n",
                    /* End_of_format */0
                  ]),
                "benchmarks:\n"
              ]);
          return list(output, functions);
        }
      };
      return with_output(f$1, /* None */0);
    } else {
      var newrecord = match[1].slice();
      var results = run_all((newrecord[/* verbosity */0] = /* High */803693442, newrecord[/* maximal_cost */6] = /* Longer */2, newrecord), functions);
      return List.iter((function (param) {
                    return output$1(Pervasives.stdout, param);
                  }), results);
    }
  } else {
    return Pervasives.failwith("error");
  }
}

exports.compare_cost          = compare_cost;
exports.print_list            = print_list;
exports.prerr_list            = prerr_list;
exports.StringSet             = StringSet;
exports.Float                 = Float;
exports.Time                  = Time;
exports.Defaults              = Defaults;
exports.Config                = Config;
exports.Measurement_sample    = Measurement_sample;
exports.Measurement           = Measurement;
exports.stabilize_gc          = stabilize_gc;
exports.Tester                = Tester;
exports.exceeded_allowed_time = exceeded_allowed_time;
exports.run_tests             = run_tests;
exports.run_all               = run_all;
exports.with_output           = with_output;
exports.run                   = run;
/* include Not a pure module */
