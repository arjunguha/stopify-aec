// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var List              = require("bs-platform/lib/js/list.js");
var Block             = require("bs-platform/lib/js/block.js");
var Curry             = require("bs-platform/lib/js/curry.js");
var Fixture           = require("../fixture.js");
var Caml_obj          = require("bs-platform/lib/js/caml_obj.js");
var Micro_bench_run   = require("../micro_bench_run.js");
var Micro_bench_types = require("../micro_bench_types.js");

function $$return(x, k) {
  return Curry._1(k, x);
}

function map(f, seq, k) {
  return Curry._1(seq, (function (x) {
                return Curry._1(k, Curry._1(f, x));
              }));
}

function flat_map(f, seq, k) {
  return Curry._1(seq, (function (x) {
                return Curry._2(f, x, k);
              }));
}

function filter(p, seq, k) {
  return Curry._1(seq, (function (x) {
                if (Curry._1(p, x)) {
                  return Curry._1(k, x);
                } else {
                  return 0;
                }
              }));
}

function of_list(l, k) {
  return List.iter(k, l);
}

function range(i, j, k) {
  for(var x = i; x <= j; ++x){
    Curry._1(k, x);
  }
  return /* () */0;
}

function fold(f, init, seq) {
  var r = [init];
  Curry._1(seq, (function (elt) {
          r[0] = Curry._2(f, r[0], elt);
          return /* () */0;
        }));
  return r[0];
}

var Sequence = /* module */[
  /* return */$$return,
  /* map */map,
  /* flat_map */flat_map,
  /* filter */filter,
  /* of_list */of_list,
  /* range */range,
  /* fold */fold
];

function map_fold(n) {
  return fold((function (prim, prim$1) {
                return prim + prim$1 | 0;
              }), 0, (function (param) {
                var f = function (x) {
                  return n - x | 0;
                };
                return range(1, n, (function (x) {
                              return Curry._1(param, Curry._1(f, x));
                            }));
              }));
}

function map_fold_base(n) {
  var sum = 0;
  for(var i = 1; i <= n; ++i){
    var x = n - i | 0;
    sum = sum + x | 0;
  }
  return sum;
}

function flat_map_fold(n) {
  return fold((function (prim, prim$1) {
                return prim + prim$1 | 0;
              }), 0, (function (param) {
                return filter((function (x) {
                              return +(x % 10 !== 0);
                            }), (function (param) {
                              var f = function (x) {
                                return (function (param) {
                                    return range(x, n, param);
                                  });
                              };
                              return range(1, n, (function (x) {
                                            return Curry._2(f, x, param);
                                          }));
                            }), param);
              }));
}

function flat_map_fold_base(n) {
  var sum = 0;
  for(var i = 1; i <= n; ++i){
    for(var j = i; j <= n; ++j){
      if (j % 10 !== 0) {
        sum = sum + j | 0;
      }
      
    }
  }
  return sum;
}

function id(x) {
  return x;
}

function valid_trivial(_, _$1) {
  return /* Ok */0;
}

function same_as(f, n, res) {
  if (Caml_obj.caml_equal(Curry._1(f, n), res)) {
    return /* Ok */0;
  } else {
    return /* Error */["do not match"];
  }
}

var bench_map_fold_001 = /* Int_group */Block.__(3, [/* tuple */[
      /* :: */[
        /* tuple */[
          "sequence",
          map_fold
        ],
        /* :: */[
          /* tuple */[
            "baseline",
            map_fold_base
          ],
          /* [] */0
        ]
      ],
      id,
      (function (param, param$1) {
          return same_as(map_fold_base, param, param$1);
        }),
      /* :: */[
        /* tuple */[
          /* Range */Block.__(0, [
              10,
              100
            ]),
          /* Short */0
        ],
        /* :: */[
          /* tuple */[
            /* Range */Block.__(0, [
                100000,
                1000000
              ]),
            /* Short */0
          ],
          /* [] */0
        ]
      ]
    ]]);

var bench_map_fold = /* tuple */[
  "map_fold",
  bench_map_fold_001
];

var bench_flat_map_fold_001 = /* Int_group */Block.__(3, [/* tuple */[
      /* :: */[
        /* tuple */[
          "sequence",
          flat_map_fold
        ],
        /* :: */[
          /* tuple */[
            "baseline",
            flat_map_fold_base
          ],
          /* [] */0
        ]
      ],
      id,
      (function (param, param$1) {
          return same_as(flat_map_fold_base, param, param$1);
        }),
      /* :: */[
        /* tuple */[
          /* Range */Block.__(0, [
              10,
              1000
            ]),
          /* Short */0
        ],
        /* [] */0
      ]
    ]]);

var bench_flat_map_fold = /* tuple */[
  "flat_map_fold",
  bench_flat_map_fold_001
];

Micro_bench_types.add(/* :: */[
      bench_map_fold,
      /* :: */[
        bench_flat_map_fold,
        /* [] */0
      ]
    ]);

var config = Micro_bench_run.Config[/* parse */1](/* () */0);

if (typeof config === "number") {
  Micro_bench_run.run(/* Some */[/* Some */[config]], Micro_bench_types.functions(/* () */0));
} else if (config[0] !== 4103979) {
  Micro_bench_run.run(/* Some */[/* Some */[config]], Micro_bench_types.functions(/* () */0));
} else {
  var conf = config[1];
  Fixture.run_n_times(1, (function () {
          var newrecord = conf.slice();
          return Micro_bench_run.run(/* Some */[/* Some */[/* `Run */[
                          4103979,
                          (newrecord[/* number_of_different_values */5] = 100, newrecord)
                        ]]], Micro_bench_types.functions(/* () */0));
        }));
}

var M = 0;

exports.Sequence            = Sequence;
exports.map_fold            = map_fold;
exports.map_fold_base       = map_fold_base;
exports.flat_map_fold       = flat_map_fold;
exports.flat_map_fold_base  = flat_map_fold_base;
exports.M                   = M;
exports.id                  = id;
exports.valid_trivial       = valid_trivial;
exports.same_as             = same_as;
exports.bench_map_fold      = bench_map_fold;
exports.bench_flat_map_fold = bench_flat_map_fold;
/*  Not a pure module */
