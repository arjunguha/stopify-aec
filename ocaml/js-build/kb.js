// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var Sys                     = require("bs-platform/lib/js/sys.js");
var List                    = require("bs-platform/lib/js/list.js");
var Block                   = require("bs-platform/lib/js/block.js");
var Curry                   = require("bs-platform/lib/js/curry.js");
var Buffer                  = require("bs-platform/lib/js/buffer.js");
var Js_exn                  = require("bs-platform/lib/js/js_exn.js");
var Fixture                 = require("../fixture.js");
var Caml_obj                = require("bs-platform/lib/js/caml_obj.js");
var Caml_array              = require("bs-platform/lib/js/caml_array.js");
var Pervasives              = require("bs-platform/lib/js/pervasives.js");
var Micro_bench_run         = require("../micro_bench_run.js");
var Micro_bench_types       = require("../micro_bench_types.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var result = "1 : U*v1 = v1\n2 : I(v1)*v1 = U\n3 : (v3*v2)*v1 = v3*(v2*v1)\n4 : A*B = B*A\n5 : C*C = U\n6 : I(A) = C*(A*C)\n8 : I(v2)*(v2*v1) = v1\n9 : A*(B*v1) = B*(A*v1)\n10 : C*(C*v1) = v1\n21 : v1*U = v1\n22 : I(C) = C\n23 : C*B = B*C\n38 : v1*I(v1) = U\n40 : v2*(I(v2)*v1) = v1\n41 : I(U) = U\n42 : I(I(v1)) = v1\n43 : C*(B*v1) = B*(C*v1)\n44 : A*(C*(A*v1)) = C*v1\n45 : A*(C*A) = C\n129 : A*I(B) = I(B)*A\n130 : I(v1*v2) = I(v2)*I(v1)\n134 : A*(I(B)*v1) = I(B)*(A*v1)\n135 : C*I(B) = I(B)*C\n136 : C*(I(B)*v1) = I(B)*(C*v1)\n";

var Result = /* module */[/* result */result];

function union(_l1, l2) {
  while(true) {
    var l1 = _l1;
    if (l1) {
      var r = l1[1];
      var a = l1[0];
      if (List.mem(a, l2)) {
        _l1 = r;
        continue ;
        
      } else {
        return /* :: */[
                a,
                union(r, l2)
              ];
      }
    } else {
      return l2;
    }
  };
}

function vars(param) {
  if (param.tag) {
    return vars_of_list(param[1]);
  } else {
    return /* :: */[
            param[0],
            /* [] */0
          ];
  }
}

function vars_of_list(param) {
  if (param) {
    return union(vars(param[0]), vars_of_list(param[1]));
  } else {
    return /* [] */0;
  }
}

function substitute(subst, t) {
  if (t.tag) {
    return /* Term */Block.__(1, [
              t[0],
              List.map((function (param) {
                      return substitute(subst, param);
                    }), t[1])
            ]);
  } else {
    try {
      return List.assoc(t[0], subst);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return t;
      } else {
        throw exn;
      }
    }
  }
}

function replace(m, u, n) {
  if (u) {
    if (m.tag) {
      return /* Term */Block.__(1, [
                m[0],
                replace_nth(u[0], m[1], u[1], n)
              ]);
    } else {
      return Pervasives.failwith("replace");
    }
  } else {
    return n;
  }
}

function replace_nth(i, sons, u, n) {
  if (sons) {
    var r = sons[1];
    var s = sons[0];
    if (i === 1) {
      return /* :: */[
              replace(s, u, n),
              r
            ];
    } else {
      return /* :: */[
              s,
              replace_nth(i - 1 | 0, r, u, n)
            ];
    }
  } else {
    return Pervasives.failwith("replace_nth");
  }
}

function matching(term1, term2) {
  var match_rec = function (subst, t1, t2) {
    if (t1.tag) {
      if (!t2.tag || t1[0] !== t2[0]) {
        return Pervasives.failwith("matching");
      } else {
        return List.fold_left2(match_rec, subst, t1[1], t2[1]);
      }
    } else {
      var v = t1[0];
      if (List.mem_assoc(v, subst)) {
        if (Caml_obj.caml_equal(t2, List.assoc(v, subst))) {
          return subst;
        } else {
          return Pervasives.failwith("matching");
        }
      } else {
        return /* :: */[
                /* tuple */[
                  v,
                  t2
                ],
                subst
              ];
      }
    }
  };
  return match_rec(/* [] */0, term1, term2);
}

function compsubst(subst1, subst2) {
  return Pervasives.$at(List.map((function (param) {
                    return /* tuple */[
                            param[0],
                            substitute(subst1, param[1])
                          ];
                  }), subst2), subst1);
}

function occurs(n, param) {
  if (param.tag) {
    return List.exists((function (param) {
                  return occurs(n, param);
                }), param[1]);
  } else {
    return +(param[0] === n);
  }
}

function unify(term1, term2) {
  if (term1.tag) {
    if (term2.tag) {
      if (term1[0] === term2[0]) {
        return List.fold_left2((function (s, t1, t2) {
                      return compsubst(unify(substitute(s, t1), substitute(s, t2)), s);
                    }), /* [] */0, term1[1], term2[1]);
      } else {
        return Pervasives.failwith("unify");
      }
    } else {
      var n2 = term2[0];
      if (occurs(n2, term1)) {
        return Pervasives.failwith("unify");
      } else {
        return /* :: */[
                /* tuple */[
                  n2,
                  term1
                ],
                /* [] */0
              ];
      }
    }
  } else if (Caml_obj.caml_equal(term1, term2)) {
    return /* [] */0;
  } else {
    var n1 = term1[0];
    if (occurs(n1, term2)) {
      return Pervasives.failwith("unify");
    } else {
      return /* :: */[
              /* tuple */[
                n1,
                term2
              ],
              /* [] */0
            ];
    }
  }
}

var infixes = /* :: */[
  "+",
  /* :: */[
    "*",
    /* [] */0
  ]
];

function pretty_term(b, param) {
  if (param.tag) {
    var sons = param[1];
    var oper = param[0];
    if (List.mem(oper, infixes)) {
      if (sons) {
        var match = sons[1];
        if (match && !match[1]) {
          pretty_close(b, sons[0]);
          Buffer.add_string(b, oper);
          return pretty_close(b, match[0]);
        } else {
          return Pervasives.failwith("pretty_term : infix arity <> 2");
        }
      } else {
        return Pervasives.failwith("pretty_term : infix arity <> 2");
      }
    } else {
      Buffer.add_string(b, oper);
      if (sons) {
        Buffer.add_char(b, /* "(" */40);
        pretty_term(b, sons[0]);
        List.iter((function (t) {
                Buffer.add_char(b, /* "," */44);
                return pretty_term(b, t);
              }), sons[1]);
        return Buffer.add_char(b, /* ")" */41);
      } else {
        return /* () */0;
      }
    }
  } else {
    Buffer.add_char(b, /* "v" */118);
    return Buffer.add_string(b, Pervasives.string_of_int(param[0]));
  }
}

function pretty_close(b, m) {
  if (!m.tag || !List.mem(m[0], infixes)) {
    return pretty_term(b, m);
  } else {
    Buffer.add_char(b, /* "(" */40);
    pretty_term(b, m);
    return Buffer.add_char(b, /* ")" */41);
  }
}

var Terms = /* module */[
  /* union */union,
  /* vars */vars,
  /* vars_of_list */vars_of_list,
  /* substitute */substitute,
  /* replace */replace,
  /* replace_nth */replace_nth,
  /* matching */matching,
  /* compsubst */compsubst,
  /* occurs */occurs,
  /* unify */unify,
  /* infixes */infixes,
  /* pretty_term */pretty_term,
  /* pretty_close */pretty_close
];

function mk_rule(num, m, n) {
  var all_vars = union(vars(m), vars(n));
  var counter = [0];
  var subst = List.map((function (v) {
          counter[0] = counter[0] + 1 | 0;
          return /* tuple */[
                  v,
                  /* Var */Block.__(0, [counter[0]])
                ];
        }), List.rev(all_vars));
  return /* record */[
          /* number */num,
          /* numvars */counter[0],
          /* lhs */substitute(subst, m),
          /* rhs */substitute(subst, n)
        ];
}

function check_rules(rules) {
  var counter = [0];
  List.iter((function (r) {
          counter[0] = counter[0] + 1 | 0;
          if (r[/* number */0] !== counter[0]) {
            return Pervasives.failwith("Rule numbers not in sequence");
          } else {
            return 0;
          }
        }), rules);
  return counter[0];
}

function pretty_rule(b, rule) {
  Buffer.add_string(b, Pervasives.string_of_int(rule[/* number */0]));
  Buffer.add_string(b, " : ");
  pretty_term(b, rule[/* lhs */2]);
  Buffer.add_string(b, " = ");
  pretty_term(b, rule[/* rhs */3]);
  return Buffer.add_char(b, /* "\n" */10);
}

function pretty_rules(b, rules) {
  return List.iter((function (param) {
                return pretty_rule(b, param);
              }), rules);
}

function reduce(l, m, r) {
  return substitute(matching(l, m), r);
}

function can_match(l, m) {
  try {
    matching(l, m);
    return /* true */1;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function reducible(l, m) {
  if (can_match(l, m)) {
    return /* true */1;
  } else if (m.tag) {
    return List.exists((function (param) {
                  return reducible(l, param);
                }), m[1]);
  } else {
    return /* false */0;
  }
}

function mreduce(_rules, m) {
  while(true) {
    var rules = _rules;
    if (rules) {
      var rule = rules[0];
      try {
        return reduce(rule[/* lhs */2], m, rule[/* rhs */3]);
      }
      catch (raw_exn){
        var exn = Js_exn.internalToOCamlException(raw_exn);
        if (exn[0] === Caml_builtin_exceptions.failure) {
          _rules = rules[1];
          continue ;
          
        } else {
          throw exn;
        }
      }
    } else {
      return Pervasives.failwith("mreduce");
    }
  };
}

function mrewrite1(rules, m) {
  try {
    return mreduce(rules, m);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      if (m.tag) {
        return /* Term */Block.__(1, [
                  m[0],
                  mrewrite1_sons(rules, m[1])
                ]);
      } else {
        return Pervasives.failwith("mrewrite1");
      }
    } else {
      throw exn;
    }
  }
}

function mrewrite1_sons(rules, param) {
  if (param) {
    var rest = param[1];
    var son = param[0];
    try {
      return /* :: */[
              mrewrite1(rules, son),
              rest
            ];
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Caml_builtin_exceptions.failure) {
        return /* :: */[
                son,
                mrewrite1_sons(rules, rest)
              ];
      } else {
        throw exn;
      }
    }
  } else {
    return Pervasives.failwith("mrewrite1");
  }
}

function mrewrite_all(rules, m) {
  try {
    return mrewrite_all(rules, mrewrite1(rules, m));
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      return m;
    } else {
      throw exn;
    }
  }
}

var Equations = /* module */[
  /* mk_rule */mk_rule,
  /* check_rules */check_rules,
  /* pretty_rule */pretty_rule,
  /* pretty_rules */pretty_rules,
  /* reduce */reduce,
  /* can_match */can_match,
  /* reducible */reducible,
  /* mreduce */mreduce,
  /* mrewrite1 */mrewrite1,
  /* mrewrite1_sons */mrewrite1_sons,
  /* mrewrite_all */mrewrite_all
];

function ge_ord(order, pair) {
  var match = Curry._1(order, pair);
  if (match >= 2) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function gt_ord(order, pair) {
  var match = Curry._1(order, pair);
  if (match !== 0) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function eq_ord(order, pair) {
  var match = Curry._1(order, pair);
  if (match !== 1) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function rem_eq(equiv, x, param) {
  if (param) {
    var l = param[1];
    var y = param[0];
    if (Curry._1(equiv, /* tuple */[
            x,
            y
          ])) {
      return l;
    } else {
      return /* :: */[
              y,
              rem_eq(equiv, x, l)
            ];
    }
  } else {
    return Pervasives.failwith("rem_eq");
  }
}

function diff_eq(equiv, param) {
  var y = param[1];
  var x = param[0];
  var diffrec = function (p) {
    var match = p[0];
    if (match) {
      var y = p[1];
      var t = match[1];
      var h = match[0];
      try {
        return diffrec(/* tuple */[
                    t,
                    rem_eq(equiv, h, y)
                  ]);
      }
      catch (raw_exn){
        var exn = Js_exn.internalToOCamlException(raw_exn);
        if (exn[0] === Caml_builtin_exceptions.failure) {
          var match$1 = diffrec(/* tuple */[
                t,
                y
              ]);
          return /* tuple */[
                  /* :: */[
                    h,
                    match$1[0]
                  ],
                  match$1[1]
                ];
        } else {
          throw exn;
        }
      }
    } else {
      return p;
    }
  };
  if (List.length(x) > List.length(y)) {
    return diffrec(/* tuple */[
                y,
                x
              ]);
  } else {
    return diffrec(/* tuple */[
                x,
                y
              ]);
  }
}

function mult_ext(order, param) {
  var match = param[0];
  if (match.tag) {
    var match$1 = param[1];
    if (match$1.tag) {
      var match$2 = diff_eq((function (param) {
              return eq_ord(order, param);
            }), /* tuple */[
            match[1],
            match$1[1]
          ]);
      var l1 = match$2[0];
      var exit = 0;
      if (l1) {
        exit = 1;
      } else if (match$2[1]) {
        exit = 1;
      } else {
        return /* Equal */1;
      }
      if (exit === 1) {
        if (List.for_all((function (n) {
                  return List.exists((function (m) {
                                return gt_ord(order, /* tuple */[
                                            m,
                                            n
                                          ]);
                              }), l1);
                }), match$2[1])) {
          return /* Greater */0;
        } else {
          return /* NotGE */2;
        }
      }
      
    } else {
      return Pervasives.failwith("mult_ext");
    }
  } else {
    return Pervasives.failwith("mult_ext");
  }
}

function lex_ext(order, param) {
  var m = param[0];
  if (m.tag) {
    var n = param[1];
    if (n.tag) {
      var _param = /* tuple */[
        m[1],
        n[1]
      ];
      while(true) {
        var param$1 = _param;
        var match = param$1[0];
        if (match) {
          var match$1 = param$1[1];
          if (match$1) {
            var l2 = match$1[1];
            var l1 = match[1];
            var match$2 = Curry._1(order, /* tuple */[
                  match[0],
                  match$1[0]
                ]);
            switch (match$2) {
              case 0 : 
                  if (List.for_all((function (n$prime) {
                            return gt_ord(order, /* tuple */[
                                        m,
                                        n$prime
                                      ]);
                          }), l2)) {
                    return /* Greater */0;
                  } else {
                    return /* NotGE */2;
                  }
              case 1 : 
                  _param = /* tuple */[
                    l1,
                    l2
                  ];
                  continue ;
                  case 2 : 
                  if (List.exists((function (m$prime) {
                            return ge_ord(order, /* tuple */[
                                        m$prime,
                                        n
                                      ]);
                          }), l1)) {
                    return /* Greater */0;
                  } else {
                    return /* NotGE */2;
                  }
              
            }
          } else {
            return /* Greater */0;
          }
        } else if (param$1[1]) {
          return /* NotGE */2;
        } else {
          return /* Equal */1;
        }
      };
    } else {
      return Pervasives.failwith("lex_ext");
    }
  } else {
    return Pervasives.failwith("lex_ext");
  }
}

function rpo(op_order, ext) {
  var rporec = function (param) {
    var n = param[1];
    var m = param[0];
    if (Caml_obj.caml_equal(m, n)) {
      return /* Equal */1;
    } else if (m.tag) {
      if (n.tag) {
        var match = Curry._2(op_order, m[0], n[0]);
        switch (match) {
          case 0 : 
              if (List.for_all((function (n$prime) {
                        return gt_ord(rporec, /* tuple */[
                                    m,
                                    n$prime
                                  ]);
                      }), n[1])) {
                return /* Greater */0;
              } else {
                return /* NotGE */2;
              }
          case 1 : 
              return Curry._2(ext, rporec, /* tuple */[
                          m,
                          n
                        ]);
          case 2 : 
              if (List.exists((function (m$prime) {
                        return ge_ord(rporec, /* tuple */[
                                    m$prime,
                                    n
                                  ]);
                      }), m[1])) {
                return /* Greater */0;
              } else {
                return /* NotGE */2;
              }
          
        }
      } else if (occurs(n[0], m)) {
        return /* Greater */0;
      } else {
        return /* NotGE */2;
      }
    } else {
      return /* NotGE */2;
    }
  };
  return rporec;
}

var Orderings = /* module */[
  /* ge_ord */ge_ord,
  /* gt_ord */gt_ord,
  /* eq_ord */eq_ord,
  /* rem_eq */rem_eq,
  /* diff_eq */diff_eq,
  /* mult_ext */mult_ext,
  /* lex_ext */lex_ext,
  /* rpo */rpo
];

function $$super(m, n) {
  if (n.tag) {
    var collate = function (n, param) {
      if (param) {
        return Pervasives.$at(List.map((function (param) {
                          return /* tuple */[
                                  /* :: */[
                                    n,
                                    param[0]
                                  ],
                                  param[1]
                                ];
                        }), $$super(m, param[0])), collate(n + 1 | 0, param[1]));
      } else {
        return /* [] */0;
      }
    };
    var insides = collate(1, n[1]);
    try {
      return /* :: */[
              /* tuple */[
                /* [] */0,
                unify(m, n)
              ],
              insides
            ];
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Caml_builtin_exceptions.failure) {
        return insides;
      } else {
        throw exn;
      }
    }
  } else {
    return /* [] */0;
  }
}

function super_strict(m, param) {
  if (param.tag) {
    var collate = function (n, param) {
      if (param) {
        return Pervasives.$at(List.map((function (param) {
                          return /* tuple */[
                                  /* :: */[
                                    n,
                                    param[0]
                                  ],
                                  param[1]
                                ];
                        }), $$super(m, param[0])), collate(n + 1 | 0, param[1]));
      } else {
        return /* [] */0;
      }
    };
    return collate(1, param[1]);
  } else {
    return /* [] */0;
  }
}

function critical_pairs(param, param$1) {
  var r2 = param$1[1];
  var l2 = param$1[0];
  var r1 = param[1];
  var mk_pair = function (param) {
    var subst = param[1];
    return /* tuple */[
            substitute(subst, replace(l2, param[0], r1)),
            substitute(subst, r2)
          ];
  };
  return List.map(mk_pair, $$super(param[0], l2));
}

function strict_critical_pairs(param, param$1) {
  var r2 = param$1[1];
  var l2 = param$1[0];
  var r1 = param[1];
  var mk_pair = function (param) {
    var subst = param[1];
    return /* tuple */[
            substitute(subst, replace(l2, param[0], r1)),
            substitute(subst, r2)
          ];
  };
  return List.map(mk_pair, super_strict(param[0], l2));
}

function mutual_critical_pairs(eq1, eq2) {
  return Pervasives.$at(strict_critical_pairs(eq1, eq2), critical_pairs(eq2, eq1));
}

function rename(n, param) {
  var ren_rec = function (param) {
    if (param.tag) {
      return /* Term */Block.__(1, [
                param[0],
                List.map(ren_rec, param[1])
              ]);
    } else {
      return /* Var */Block.__(0, [param[0] + n | 0]);
    }
  };
  return /* tuple */[
          ren_rec(param[0]),
          ren_rec(param[1])
        ];
}

function deletion_message(rule) {
  var b = Buffer.create(20);
  Buffer.add_string(b, "Rule ");
  Buffer.add_string(b, Pervasives.string_of_int(rule[/* number */0]));
  Buffer.add_string(b, " deleted");
  console.log(Buffer.contents(b));
  return /* () */0;
}

function non_orientable(param) {
  var b = Buffer.create(20);
  pretty_term(b, param[0]);
  Buffer.add_string(b, " = ");
  pretty_term(b, param[1]);
  console.log(Buffer.contents(b));
  return /* () */0;
}

function partition(p, param) {
  if (param) {
    var x = param[0];
    var match = partition(p, param[1]);
    var l2 = match[1];
    var l1 = match[0];
    if (Curry._1(p, x)) {
      return /* tuple */[
              /* :: */[
                x,
                l1
              ],
              l2
            ];
    } else {
      return /* tuple */[
              l1,
              /* :: */[
                x,
                l2
              ]
            ];
    }
  } else {
    return /* tuple */[
            /* [] */0,
            /* [] */0
          ];
  }
}

function get_rule(n, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var r = param[0];
      if (n === r[/* number */0]) {
        return r;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function kb_completion(greater) {
  var kbrec = function (j, rules) {
    var $$process = function (_failures, _param, _eqs) {
      while(true) {
        var param = _param;
        var eqs = _eqs;
        var failures = _failures;
        var l = param[1];
        var k = param[0];
        if (eqs) {
          var eqs$1 = eqs[1];
          var match = eqs[0];
          var m$prime = mrewrite_all(rules, match[0]);
          var n$prime = mrewrite_all(rules, match[1]);
          var enter_rule = (function(failures,k,l,eqs$1){
          return function enter_rule(param) {
            var left = param[0];
            var new_rule = mk_rule(j + 1 | 0, left, param[1]);
            var left_reducible = function (rule) {
              return reducible(left, rule[/* lhs */2]);
            };
            var match = partition(left_reducible, rules);
            var right_reduce = function (rule) {
              return mk_rule(rule[/* number */0], rule[/* lhs */2], mrewrite_all(/* :: */[
                              new_rule,
                              rules
                            ], rule[/* rhs */3]));
            };
            var irreds = List.map(right_reduce, match[1]);
            var eqs$prime = List.map((function (rule) {
                    return /* tuple */[
                            rule[/* lhs */2],
                            rule[/* rhs */3]
                          ];
                  }), match[0]);
            return kbrec(j + 1 | 0, /* :: */[
                          new_rule,
                          irreds
                        ])(/* [] */0, /* tuple */[
                        k,
                        l
                      ], Pervasives.$at(eqs$1, Pervasives.$at(eqs$prime, failures)));
          }
          }(failures,k,l,eqs$1));
          if (Caml_obj.caml_equal(m$prime, n$prime)) {
            _eqs = eqs$1;
            _param = /* tuple */[
              k,
              l
            ];
            continue ;
            
          } else if (Curry._1(greater, /* tuple */[
                  m$prime,
                  n$prime
                ])) {
            return enter_rule(/* tuple */[
                        m$prime,
                        n$prime
                      ]);
          } else if (Curry._1(greater, /* tuple */[
                  n$prime,
                  m$prime
                ])) {
            return enter_rule(/* tuple */[
                        n$prime,
                        m$prime
                      ]);
          } else {
            _eqs = eqs$1;
            _param = /* tuple */[
              k,
              l
            ];
            _failures = /* :: */[
              /* tuple */[
                m$prime,
                n$prime
              ],
              failures
            ];
            continue ;
            
          }
        } else if (k < l) {
          return next_criticals(failures, /* tuple */[
                      k + 1 | 0,
                      l
                    ]);
        } else if (l < j) {
          return next_criticals(failures, /* tuple */[
                      1,
                      l + 1 | 0
                    ]);
        } else if (failures) {
          Pervasives.print_string("Non-orientable equations :");
          Pervasives.print_newline(/* () */0);
          List.iter(non_orientable, failures);
          return Pervasives.failwith("kb_completion");
        } else {
          return rules;
        }
      };
    };
    var next_criticals = function (failures, _param) {
      while(true) {
        var param = _param;
        var l = param[1];
        var k = param[0];
        try {
          var rl = get_rule(l, rules);
          var el_000 = rl[/* lhs */2];
          var el_001 = rl[/* rhs */3];
          var el = /* tuple */[
            el_000,
            el_001
          ];
          if (k === l) {
            return $$process(failures, /* tuple */[
                        k,
                        l
                      ], strict_critical_pairs(el, rename(rl[/* numvars */1], el)));
          } else {
            try {
              var rk = get_rule(k, rules);
              var ek_000 = rk[/* lhs */2];
              var ek_001 = rk[/* rhs */3];
              var ek = /* tuple */[
                ek_000,
                ek_001
              ];
              return $$process(failures, /* tuple */[
                          k,
                          l
                        ], mutual_critical_pairs(el, rename(rl[/* numvars */1], ek)));
            }
            catch (exn){
              if (exn === Caml_builtin_exceptions.not_found) {
                return next_criticals(failures, /* tuple */[
                            k + 1 | 0,
                            l
                          ]);
              } else {
                throw exn;
              }
            }
          }
        }
        catch (exn$1){
          if (exn$1 === Caml_builtin_exceptions.not_found) {
            _param = /* tuple */[
              1,
              l + 1 | 0
            ];
            continue ;
            
          } else {
            throw exn$1;
          }
        }
      };
    };
    return $$process;
  };
  return kbrec;
}

function kb_complete(b, greater, complete_rules, rules) {
  var n = check_rules(complete_rules);
  var eqs = List.map((function (rule) {
          return /* tuple */[
                  rule[/* lhs */2],
                  rule[/* rhs */3]
                ];
        }), rules);
  var completed_rules = Curry._3(kb_completion(greater)(n, complete_rules), /* [] */0, /* tuple */[
        n,
        n
      ], eqs);
  Buffer.add_string(b, "Canonical set found :\n");
  var rules$1 = List.rev(completed_rules);
  return List.iter((function (param) {
                return pretty_rule(b, param);
              }), rules$1);
}

var Kb = /* module */[
  /* super */$$super,
  /* super_strict */super_strict,
  /* critical_pairs */critical_pairs,
  /* strict_critical_pairs */strict_critical_pairs,
  /* mutual_critical_pairs */mutual_critical_pairs,
  /* rename */rename,
  /* deletion_message */deletion_message,
  /* non_orientable */non_orientable,
  /* partition */partition,
  /* get_rule */get_rule,
  /* kb_completion */kb_completion,
  /* kb_complete */kb_complete
];

var geom_rules = /* :: */[
  /* record */[
    /* number */1,
    /* numvars */1,
    /* lhs : Term */Block.__(1, [
        "*",
        /* :: */[
          /* Term */Block.__(1, [
              "U",
              /* [] */0
            ]),
          /* :: */[
            /* Var */Block.__(0, [1]),
            /* [] */0
          ]
        ]
      ]),
    /* rhs : Var */Block.__(0, [1])
  ],
  /* :: */[
    /* record */[
      /* number */2,
      /* numvars */1,
      /* lhs : Term */Block.__(1, [
          "*",
          /* :: */[
            /* Term */Block.__(1, [
                "I",
                /* :: */[
                  /* Var */Block.__(0, [1]),
                  /* [] */0
                ]
              ]),
            /* :: */[
              /* Var */Block.__(0, [1]),
              /* [] */0
            ]
          ]
        ]),
      /* rhs : Term */Block.__(1, [
          "U",
          /* [] */0
        ])
    ],
    /* :: */[
      /* record */[
        /* number */3,
        /* numvars */3,
        /* lhs : Term */Block.__(1, [
            "*",
            /* :: */[
              /* Term */Block.__(1, [
                  "*",
                  /* :: */[
                    /* Var */Block.__(0, [1]),
                    /* :: */[
                      /* Var */Block.__(0, [2]),
                      /* [] */0
                    ]
                  ]
                ]),
              /* :: */[
                /* Var */Block.__(0, [3]),
                /* [] */0
              ]
            ]
          ]),
        /* rhs : Term */Block.__(1, [
            "*",
            /* :: */[
              /* Var */Block.__(0, [1]),
              /* :: */[
                /* Term */Block.__(1, [
                    "*",
                    /* :: */[
                      /* Var */Block.__(0, [2]),
                      /* :: */[
                        /* Var */Block.__(0, [3]),
                        /* [] */0
                      ]
                    ]
                  ]),
                /* [] */0
              ]
            ]
          ])
      ],
      /* :: */[
        /* record */[
          /* number */4,
          /* numvars */0,
          /* lhs : Term */Block.__(1, [
              "*",
              /* :: */[
                /* Term */Block.__(1, [
                    "A",
                    /* [] */0
                  ]),
                /* :: */[
                  /* Term */Block.__(1, [
                      "B",
                      /* [] */0
                    ]),
                  /* [] */0
                ]
              ]
            ]),
          /* rhs : Term */Block.__(1, [
              "*",
              /* :: */[
                /* Term */Block.__(1, [
                    "B",
                    /* [] */0
                  ]),
                /* :: */[
                  /* Term */Block.__(1, [
                      "A",
                      /* [] */0
                    ]),
                  /* [] */0
                ]
              ]
            ])
        ],
        /* :: */[
          /* record */[
            /* number */5,
            /* numvars */0,
            /* lhs : Term */Block.__(1, [
                "*",
                /* :: */[
                  /* Term */Block.__(1, [
                      "C",
                      /* [] */0
                    ]),
                  /* :: */[
                    /* Term */Block.__(1, [
                        "C",
                        /* [] */0
                      ]),
                    /* [] */0
                  ]
                ]
              ]),
            /* rhs : Term */Block.__(1, [
                "U",
                /* [] */0
              ])
          ],
          /* :: */[
            /* record */[
              /* number */6,
              /* numvars */0,
              /* lhs : Term */Block.__(1, [
                  "*",
                  /* :: */[
                    /* Term */Block.__(1, [
                        "C",
                        /* [] */0
                      ]),
                    /* :: */[
                      /* Term */Block.__(1, [
                          "*",
                          /* :: */[
                            /* Term */Block.__(1, [
                                "A",
                                /* [] */0
                              ]),
                            /* :: */[
                              /* Term */Block.__(1, [
                                  "I",
                                  /* :: */[
                                    /* Term */Block.__(1, [
                                        "C",
                                        /* [] */0
                                      ]),
                                    /* [] */0
                                  ]
                                ]),
                              /* [] */0
                            ]
                          ]
                        ]),
                      /* [] */0
                    ]
                  ]
                ]),
              /* rhs : Term */Block.__(1, [
                  "I",
                  /* :: */[
                    /* Term */Block.__(1, [
                        "A",
                        /* [] */0
                      ]),
                    /* [] */0
                  ]
                ])
            ],
            /* :: */[
              /* record */[
                /* number */7,
                /* numvars */0,
                /* lhs : Term */Block.__(1, [
                    "*",
                    /* :: */[
                      /* Term */Block.__(1, [
                          "C",
                          /* [] */0
                        ]),
                      /* :: */[
                        /* Term */Block.__(1, [
                            "*",
                            /* :: */[
                              /* Term */Block.__(1, [
                                  "B",
                                  /* [] */0
                                ]),
                              /* :: */[
                                /* Term */Block.__(1, [
                                    "I",
                                    /* :: */[
                                      /* Term */Block.__(1, [
                                          "C",
                                          /* [] */0
                                        ]),
                                      /* [] */0
                                    ]
                                  ]),
                                /* [] */0
                              ]
                            ]
                          ]),
                        /* [] */0
                      ]
                    ]
                  ]),
                /* rhs : Term */Block.__(1, [
                    "B",
                    /* [] */0
                  ])
              ],
              /* [] */0
            ]
          ]
        ]
      ]
    ]
  ]
];

function group_rank(param) {
  switch (param) {
    case "*" : 
        return 1;
    case "A" : 
        return 5;
    case "B" : 
        return 3;
    case "C" : 
        return 4;
    case "I" : 
        return 2;
    case "U" : 
        return 0;
    default:
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "kb.ml",
              640,
              9
            ]
          ];
  }
}

function group_precedence(op1, op2) {
  var r1 = group_rank(op1);
  var r2 = group_rank(op2);
  if (r1 === r2) {
    return /* Equal */1;
  } else if (r1 > r2) {
    return /* Greater */0;
  } else {
    return /* NotGE */2;
  }
}

var group_order = rpo(group_precedence, lex_ext);

function greater(pair) {
  var match = group_order(pair);
  if (match !== 0) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function complete(greater, complete_rules, rules) {
  var n = check_rules(complete_rules);
  var eqs = List.map((function (rule) {
          return /* tuple */[
                  rule[/* lhs */2],
                  rule[/* rhs */3]
                ];
        }), rules);
  return List.rev(Curry._3(kb_completion(greater)(n, complete_rules), /* [] */0, /* tuple */[
                  n,
                  n
                ], eqs));
}

function check_string(l) {
  var b = Buffer.create(10000);
  List.iter((function (param) {
          return pretty_rule(b, param);
        }), l);
  return Buffer.contents(b);
}

function check_geom_rules(l) {
  var s = check_string(l);
  if (s === result) {
    return /* Ok */0;
  } else {
    return /* Error */["\n" + s];
  }
}

var functions_000 = /* tuple */[
  "kb geom_rules",
  /* Unit */Block.__(0, [/* tuple */[
        (function () {
            return complete(greater, /* [] */0, geom_rules);
          }),
        check_geom_rules,
        /* Long */1
      ]])
];

var functions = /* :: */[
  functions_000,
  /* [] */0
];

Micro_bench_types.add(functions);

function save_result() {
  var s = check_string(complete(greater, /* [] */0, geom_rules));
  Pervasives.output_string(Pervasives.stdout, "let result =\n\"");
  Pervasives.output_string(Pervasives.stdout, s);
  return Pervasives.output_string(Pervasives.stdout, "\"");
}

if (Sys.argv.length > 1 && Caml_array.caml_array_get(Sys.argv, 1) === "make-result") {
  save_result(/* () */0);
}

Fixture.run_n_times(3, (function () {
        return Micro_bench_run.run(/* None */0, Micro_bench_types.functions(/* () */0));
      }));

exports.Result           = Result;
exports.Terms            = Terms;
exports.Equations        = Equations;
exports.Orderings        = Orderings;
exports.Kb               = Kb;
exports.geom_rules       = geom_rules;
exports.group_rank       = group_rank;
exports.group_precedence = group_precedence;
exports.group_order      = group_order;
exports.greater          = greater;
exports.complete         = complete;
exports.check_string     = check_string;
exports.check_geom_rules = check_geom_rules;
exports.functions        = functions;
exports.save_result      = save_result;
/* group_order Not a pure module */
