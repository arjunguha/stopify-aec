// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var List                    = require("bs-platform/lib/js/list.js");
var Block                   = require("bs-platform/lib/js/block.js");
var Curry                   = require("bs-platform/lib/js/curry.js");
var Fixture                 = require("../fixture.js");
var Caml_obj                = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32              = require("bs-platform/lib/js/caml_int32.js");
var Pervasives              = require("bs-platform/lib/js/pervasives.js");
var Micro_bench_run         = require("../micro_bench_run.js");
var Micro_bench_types       = require("../micro_bench_types.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function interval_direct(i, j) {
  if (i <= j) {
    return /* :: */[
            i,
            interval_direct(i + 1 | 0, j)
          ];
  } else {
    return /* [] */0;
  }
}

function interval_tail_rec(i, j) {
  var _acc = /* [] */0;
  var i$1 = i;
  var _j = j;
  while(true) {
    var j$1 = _j;
    var acc = _acc;
    if (i$1 <= j$1) {
      _j = j$1 - 1 | 0;
      _acc = /* :: */[
        j$1,
        acc
      ];
      continue ;
      
    } else {
      return acc;
    }
  };
}

function interval_tail_rec_with_closure(i, j) {
  var _acc = /* [] */0;
  var _j = j;
  while(true) {
    var j$1 = _j;
    var acc = _acc;
    if (i <= j$1) {
      _j = j$1 - 1 | 0;
      _acc = /* :: */[
        j$1,
        acc
      ];
      continue ;
      
    } else {
      return acc;
    }
  };
}

function list_rev(l) {
  var _acc = /* [] */0;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var acc = _acc;
    if (l$1) {
      _l = l$1[1];
      _acc = /* :: */[
        l$1[0],
        acc
      ];
      continue ;
      
    } else {
      return acc;
    }
  };
}

function list_rev_while(l) {
  var l$1 = l;
  var acc = /* [] */0;
  var $$continue = /* true */1;
  while($$continue) {
    var match = l$1;
    if (match) {
      l$1 = match[1];
      acc = /* :: */[
        match[0],
        acc
      ];
    } else {
      $$continue = /* false */0;
    }
  };
  return acc;
}

function map_direct(f, l) {
  if (l) {
    return /* :: */[
            Curry._1(f, l[0]),
            map_direct(f, l[1])
          ];
  } else {
    return /* [] */0;
  }
}

function map_direct_closure(f, l) {
  var aux = function (l) {
    if (l) {
      return /* :: */[
              Curry._1(f, l[0]),
              aux(l[1])
            ];
    } else {
      return /* [] */0;
    }
  };
  return aux(l);
}

function map_tail_rec(f, l) {
  var aux = function (_acc, f, _l) {
    while(true) {
      var l = _l;
      var acc = _acc;
      if (l) {
        _l = l[1];
        _acc = /* :: */[
          Curry._1(f, l[0]),
          acc
        ];
        continue ;
        
      } else {
        return acc;
      }
    };
  };
  return list_rev(aux(/* [] */0, f, l));
}

function rev_map_tail_rec(f, l) {
  var _acc = /* [] */0;
  var f$1 = f;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var acc = _acc;
    if (l$1) {
      _l = l$1[1];
      _acc = /* :: */[
        Curry._1(f$1, l$1[0]),
        acc
      ];
      continue ;
      
    } else {
      return acc;
    }
  };
}

function rev_map_while(f, l) {
  var l$1 = l;
  var acc = /* [] */0;
  var $$continue = /* true */1;
  while($$continue) {
    var match = l$1;
    if (match) {
      l$1 = match[1];
      acc = /* :: */[
        Curry._1(f, match[0]),
        acc
      ];
    } else {
      $$continue = /* false */0;
    }
  };
  return acc;
}

function fold_left(f, _acc, _l) {
  while(true) {
    var l = _l;
    var acc = _acc;
    if (l) {
      _l = l[1];
      _acc = Curry._2(f, acc, l[0]);
      continue ;
      
    } else {
      return acc;
    }
  };
}

function fold_left_while(f, acc, l) {
  var acc$1 = acc;
  var l$1 = l;
  var $$continue = /* true */1;
  while($$continue) {
    var match = l$1;
    if (match) {
      acc$1 = Curry._2(f, acc$1, match[0]);
      l$1 = match[1];
    } else {
      $$continue = /* false */0;
    }
  };
  return acc$1;
}

function fold_left_while_exn(f, acc, l) {
  var acc$1 = acc;
  var l$1 = l;
  try {
    while(true) {
      var match = l$1;
      if (match) {
        acc$1 = Curry._2(f, acc$1, match[0]);
        l$1 = match[1];
      } else {
        throw Pervasives.Exit;
      }
    };
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "list_main.ml",
            125,
            4
          ]
        ];
  }
  catch (exn){
    return acc$1;
  }
}

var interval_range = /* :: */[
  /* tuple */[
    /* Range */Block.__(0, [
        0,
        5000
      ]),
    /* Short */0
  ],
  /* [] */0
];

function check_interval(n, l) {
  var _param = /* tuple */[
    n,
    l
  ];
  while(true) {
    var param = _param;
    var i = param[0];
    var exit = 0;
    if (i !== -1) {
      exit = 1;
    } else if (param[1]) {
      exit = 1;
    } else {
      return /* Ok */0;
    }
    if (exit === 1) {
      var match = param[1];
      if (match) {
        if ((n - i | 0) === match[0]) {
          _param = /* tuple */[
            i - 1 | 0,
            match[1]
          ];
          continue ;
          
        } else {
          return /* Error */["mismatched value"];
        }
      } else {
        return /* Error */["mismatched length"];
      }
    }
    
  };
}

function mk_interval(f, i) {
  return Curry._2(f, 0, i);
}

var interval_group = /* Int_group */Block.__(3, [/* tuple */[
      /* :: */[
        /* tuple */[
          "direct",
          (function (param) {
              return interval_direct(0, param);
            })
        ],
        /* :: */[
          /* tuple */[
            "tail_rec",
            (function (param) {
                return interval_tail_rec(0, param);
              })
          ],
          /* :: */[
            /* tuple */[
              "tail_rec_with_closure",
              (function (param) {
                  return interval_tail_rec_with_closure(0, param);
                })
            ],
            /* [] */0
          ]
        ]
      ],
      (function (i) {
          return i;
        }),
      check_interval,
      interval_range
    ]]);

function prepare_rev(i) {
  return interval_tail_rec(0, i);
}

function check_rev(n, l) {
  var orig = interval_tail_rec(0, n);
  if (Caml_obj.caml_equal(orig, List.rev(l))) {
    return /* Ok */0;
  } else {
    return /* Error */[""];
  }
}

var rev_group = /* Int_group */Block.__(3, [/* tuple */[
      /* :: */[
        /* tuple */[
          "rec",
          list_rev
        ],
        /* :: */[
          /* tuple */[
            "rev_while",
            list_rev_while
          ],
          /* [] */0
        ]
      ],
      prepare_rev,
      check_rev,
      interval_range
    ]]);

function mk_map_succ(f, l) {
  return Curry._2(f, (function (prim) {
                return prim + 1 | 0;
              }), l);
}

function prepare_map_succ(i) {
  return interval_tail_rec(0, i);
}

function check_map_succ(i, l) {
  var orig = interval_tail_rec(0, i);
  if (Caml_obj.caml_equal(List.map((function (i) {
                return i - 1 | 0;
              }), l), orig)) {
    return /* Ok */0;
  } else {
    return /* Error */[""];
  }
}

var map_succ_group = /* Int_group */Block.__(3, [/* tuple */[
      /* :: */[
        /* tuple */[
          "direct",
          (function (param) {
              return map_direct((function (prim) {
                            return prim + 1 | 0;
                          }), param);
            })
        ],
        /* :: */[
          /* tuple */[
            "closure",
            (function (param) {
                return map_direct_closure((function (prim) {
                              return prim + 1 | 0;
                            }), param);
              })
          ],
          /* :: */[
            /* tuple */[
              "tail_rec",
              (function (param) {
                  return map_tail_rec((function (prim) {
                                return prim + 1 | 0;
                              }), param);
                })
            ],
            /* [] */0
          ]
        ]
      ],
      (function (i) {
          return interval_tail_rec(0, i);
        }),
      check_map_succ,
      interval_range
    ]]);

function prepare_rev_map_succ(i) {
  return interval_tail_rec(0, i);
}

function check_rev_map_succ(n, l) {
  var orig = interval_tail_rec(0, n);
  if (Caml_obj.caml_equal(List.rev_map((function (i) {
                return i - 1 | 0;
              }), l), orig)) {
    return /* Ok */0;
  } else {
    return /* Error */[""];
  }
}

function mk_rev_map_succ(f, l) {
  return Curry._2(f, (function (prim) {
                return prim + 1 | 0;
              }), l);
}

var rev_map_succ_group = /* Int_group */Block.__(3, [/* tuple */[
      /* :: */[
        /* tuple */[
          "rev_map_tail_rec succ",
          (function (param) {
              return rev_map_tail_rec((function (prim) {
                            return prim + 1 | 0;
                          }), param);
            })
        ],
        /* :: */[
          /* tuple */[
            "rev_map_while succ",
            (function (param) {
                return rev_map_while((function (prim) {
                              return prim + 1 | 0;
                            }), param);
              })
          ],
          /* [] */0
        ]
      ],
      prepare_rev_map_succ,
      check_rev_map_succ,
      interval_range
    ]]);

function prepare_fold_left_add(i) {
  return interval_tail_rec(0, i);
}

function check_fold_left_add(i, r) {
  if ((Caml_int32.imul(i, i + 1 | 0) / 2 | 0) === r) {
    return /* Ok */0;
  } else {
    return /* Error */[""];
  }
}

function mk_fold_left_add(f, l) {
  return Curry._3(f, (function (prim, prim$1) {
                return prim + prim$1 | 0;
              }), 0, l);
}

var fold_left_add_group = /* Int_group */Block.__(3, [/* tuple */[
      /* :: */[
        /* tuple */[
          "tail_rec",
          (function (param) {
              return mk_fold_left_add(fold_left, param);
            })
        ],
        /* :: */[
          /* tuple */[
            "while",
            (function (param) {
                return mk_fold_left_add(fold_left_while, param);
              })
          ],
          /* :: */[
            /* tuple */[
              "while_exn",
              (function (param) {
                  return mk_fold_left_add(fold_left_while_exn, param);
                })
            ],
            /* [] */0
          ]
        ]
      ],
      prepare_fold_left_add,
      check_fold_left_add,
      interval_range
    ]]);

function check_fold_left_add_float(i, r) {
  if ((Caml_int32.imul(i, i + 1 | 0) / 2 | 0) === (r | 0)) {
    return /* Ok */0;
  } else {
    return /* Error */[""];
  }
}

function mk_fold_left_add_float(f, l) {
  return Curry._3(f, (function (acc, i) {
                return acc + i;
              }), 0, l);
}

var fold_left_add_float_group = /* Int_group */Block.__(3, [/* tuple */[
      /* :: */[
        /* tuple */[
          "tail_rec",
          (function (param) {
              return mk_fold_left_add_float(fold_left, param);
            })
        ],
        /* :: */[
          /* tuple */[
            "while",
            (function (param) {
                return mk_fold_left_add_float(fold_left_while, param);
              })
          ],
          /* :: */[
            /* tuple */[
              "while_exn",
              (function (param) {
                  return mk_fold_left_add_float(fold_left_while_exn, param);
                })
            ],
            /* [] */0
          ]
        ]
      ],
      prepare_fold_left_add,
      check_fold_left_add_float,
      interval_range
    ]]);

var functions_000 = /* tuple */[
  "interval",
  interval_group
];

var functions_001 = /* :: */[
  /* tuple */[
    "rev",
    rev_group
  ],
  /* :: */[
    /* tuple */[
      "map succ",
      map_succ_group
    ],
    /* :: */[
      /* tuple */[
        "rev_map succ",
        rev_map_succ_group
      ],
      /* :: */[
        /* tuple */[
          "fold_left add",
          fold_left_add_group
        ],
        /* :: */[
          /* tuple */[
            "fold_left add_float",
            fold_left_add_float_group
          ],
          /* [] */0
        ]
      ]
    ]
  ]
];

var functions = /* :: */[
  functions_000,
  functions_001
];

Micro_bench_types.add(functions);

var config = Micro_bench_run.Config[/* parse */1](/* () */0);

if (typeof config === "number") {
  Micro_bench_run.run(/* Some */[/* Some */[config]], Micro_bench_types.functions(/* () */0));
} else if (config[0] !== 4103979) {
  Micro_bench_run.run(/* Some */[/* Some */[config]], Micro_bench_types.functions(/* () */0));
} else {
  var conf = config[1];
  Fixture.run_n_times(1, (function () {
          var newrecord = conf.slice();
          return Micro_bench_run.run(/* Some */[/* Some */[/* `Run */[
                          4103979,
                          (newrecord[/* number_of_different_values */5] = 1000, newrecord)
                        ]]], Micro_bench_types.functions(/* () */0));
        }));
}

var rev_range = interval_range;

var map_succ_range = interval_range;

var rev_map_succ_range = interval_range;

var fold_left_add_range = interval_range;

var fold_left_add_float_range = interval_range;

var prepare_fold_left_add_float = prepare_fold_left_add;

exports.interval_direct                = interval_direct;
exports.interval_tail_rec              = interval_tail_rec;
exports.interval_tail_rec_with_closure = interval_tail_rec_with_closure;
exports.list_rev                       = list_rev;
exports.list_rev_while                 = list_rev_while;
exports.map_direct                     = map_direct;
exports.map_direct_closure             = map_direct_closure;
exports.map_tail_rec                   = map_tail_rec;
exports.rev_map_tail_rec               = rev_map_tail_rec;
exports.rev_map_while                  = rev_map_while;
exports.fold_left                      = fold_left;
exports.fold_left_while                = fold_left_while;
exports.fold_left_while_exn            = fold_left_while_exn;
exports.interval_range                 = interval_range;
exports.check_interval                 = check_interval;
exports.mk_interval                    = mk_interval;
exports.interval_group                 = interval_group;
exports.rev_range                      = rev_range;
exports.prepare_rev                    = prepare_rev;
exports.check_rev                      = check_rev;
exports.rev_group                      = rev_group;
exports.mk_map_succ                    = mk_map_succ;
exports.prepare_map_succ               = prepare_map_succ;
exports.map_succ_range                 = map_succ_range;
exports.check_map_succ                 = check_map_succ;
exports.map_succ_group                 = map_succ_group;
exports.rev_map_succ_range             = rev_map_succ_range;
exports.prepare_rev_map_succ           = prepare_rev_map_succ;
exports.check_rev_map_succ             = check_rev_map_succ;
exports.mk_rev_map_succ                = mk_rev_map_succ;
exports.rev_map_succ_group             = rev_map_succ_group;
exports.fold_left_add_range            = fold_left_add_range;
exports.prepare_fold_left_add          = prepare_fold_left_add;
exports.check_fold_left_add            = check_fold_left_add;
exports.mk_fold_left_add               = mk_fold_left_add;
exports.fold_left_add_group            = fold_left_add_group;
exports.fold_left_add_float_range      = fold_left_add_float_range;
exports.prepare_fold_left_add_float    = prepare_fold_left_add_float;
exports.check_fold_left_add_float      = check_fold_left_add_float;
exports.mk_fold_left_add_float         = mk_fold_left_add_float;
exports.fold_left_add_float_group      = fold_left_add_float_group;
exports.functions                      = functions;
/*  Not a pure module */
